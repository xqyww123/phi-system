<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>File ‹library/phi_type_algebra/semantic_type.ML›</title>
</head>


<body>
<div class="head">
<h1>File ‹library/phi_type_algebra/semantic_type.ML›</h1>
</div>

<pre class="source"><span class="keyword1"><span class="keyword"><span>signature</span></span></span><span> </span><span class="entity"><span>PHI_TYPE_ALGEBRA_DERIVERS</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>sig</span></span></span><span>
</span><span class="keyword1"><span class="keyword"><span>include</span></span></span><span> </span><span class="entity"><span>PHI_TYPE_ALGEBRA_DERIVERS</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> semantic_type </span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>quiet</span></span><span> * </span><span>Position.T</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>deriving_instruction</span></span><span> </span><span>list</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Phi_Type.derive</span></span><span>

</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>structure</span></span></span><span> </span><span class="entity"><span>Phi_Type_Derivers</span></span><span> </span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>PHI_TYPE_ALGEBRA_DERIVERS</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>struct</span></span></span><span>
</span><span class="keyword3"><span class="keyword"><span>open</span></span></span><span> </span><span>Phi_Type</span><span> </span><span>Phi_Type_Derivers</span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>guess_property</span></span><span> </span><span class="entity"><span>phi</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>x_term</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>T_term</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>fix_phi_term_params</span></span><span> </span><span class="entity"><span>phi</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>arg_tys</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>x_ty</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>model_ty</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>parameters_and_typs_of</span></span><span> </span><span class="entity"><span>phi</span></span><span>

      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>exists</span><span> </span><span class="main"><span>(</span></span><span>can</span><span> </span><span class="entity"><span>dest_parameterized_phi_ty</span></span><span> </span><span>o</span><span> </span><span>snd</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>arg_tys</span></span><span>
              </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span class="entity"><span>Automation_Fail</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword3"><span class="keyword"><span>open</span></span></span><span> </span><span>Pretty</span><span> </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
                  </span><span class="main"><span>[</span></span><span>para</span><span> </span><span class="inner_quoted"><span>"Property gusser does not support type operators right now"</span></span><span class="main"><span>]</span></span><span>
                </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>)</span></span><span>
              </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span>

      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="main"><span>#</span></span><span>is_recursive </span><span class="entity"><span>phi</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span class="entity"><span>Automation_Fail</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword3"><span class="keyword"><span>open</span></span></span><span> </span><span>Pretty</span><span> </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
                </span><span class="main"><span>[</span></span><span>para</span><span> </span><span class="inner_quoted"><span>"Property gusser does not support recursive φ-types right now"</span></span><span class="main"><span>]</span></span><span>
              </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span>

   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>Seq.single</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>HOLogic.Trueprop</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span>
            </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Const</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.eq|const"><span>HOL.eq</span></a><span> </span><span class="quoted"><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Type</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../Phi_Semantics_Framework/Phi_Semantics_Framework.html#Phi_Semantics_Framework.TY|type"><span>TY</span></a><span>›</span></span></span><span>›</span></span><span>
              </span><span>$</span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Const</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../Spec_Framework.html#Spec_Framework.SType_Of|const"><span>SType_Of</span></a><span> </span><span class="entity"><span>x_ty</span></span><span>›</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>T_term</span></span><span class="main"><span>)</span></span><span>
              </span><span>$</span><span> </span><span>Var</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"TY"</span></span><span class="main"><span>,</span></span><span> </span><span class="inner_numeral"><span>0</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Type</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../Phi_Semantics_Framework/Phi_Semantics_Framework.html#Phi_Semantics_Framework.TY|type"><span>TY</span></a><span>›</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>
          </span><span>SOME</span><span> </span><span class="entity"><span>x_term</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>parse_inst_params_from_phi_term</span></span><span> </span><span class="entity"><span>T_term</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>phi</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>gen_semantic_type</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>name</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>instruction</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>phi0</span></span><span> </span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>phi_type</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>thy</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>parse_hint</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>parse_hint</span></span><span> </span><span class="main"><span>(</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Const</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../../HOL/HOL/HOL.html#HOL.eq|const"><span>HOL.eq</span></a><span> </span><span class="main"><span>_</span></span><span>›</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Const</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../Spec_Framework.html#Spec_Framework.SType_Of|const"><span>SType_Of</span></a><span> </span><span class="main"><span>_</span></span><span>›</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>T</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>T</span></span><span class="main"><span>)</span></span><span>

      </span><span class="comment1"><span>(*val equip_expansion = equip_expansion_ss phi0*)</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>ind_conv</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>default_ind_conv</span></span><span> </span><span class="main"><span>(</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                </span><span>Conv.rewr_conv</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../../IDE_CP_App2.html#offset_1091..1108"><span>φTA_SemTy_IH_rewr</span></a><span class="antiquote"><span>}</span></span></span></span><span class="main"><span>,</span></span><span>
            </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctm</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
               </span><span class="main"><span>(</span></span><span>Conv.rewr_conv</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../../Phi_Type.html#Phi_Type.\&lt;phi&gt;TA_common_rewr_imp1_noact|fact"><span>φTA_common_rewr_imp1_noact</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>then_conv</span><span>
                </span><span class="entity"><span>Phi_Reasoners.asm_rewrite</span></span><span> </span><span>true</span><span> </span><span class="main"><span>(</span></span><span>Simplifier.clear_simpset</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>addsimps</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>#</span></span><span>equations </span><span class="entity"><span>phi0</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>then_conv</span><span>
                </span><span>Conv.implies_conv</span><span> </span><span class="main"><span>(</span></span><span>Conv.rewr_conv</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../../Phi_Type.html#Phi_Type.intro_\&lt;phi&gt;TA_ANT|fact"><span>intro_φTA_ANT</span></a><span class="antiquote"><span>}</span></span></span></span><span class="main"><span>)</span></span><span> </span><span>Conv.all_conv</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctm</span></span><span class="main"><span>)</span></span><span>

      </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>varifier</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Trueprop</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span>
                </span><span class="main"><span>(</span></span><span class="entity"><span>SemTyp</span></span><span> </span><span class="keyword1"><span class="keyword"><span>as</span></span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../Spec_Framework.html#Spec_Framework.Semantic_Type&apos;|const"><span>Semantic_Type'</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>TY</span></span><span> </span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
            </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="entity"><span>TY</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>TY'</span></span><span class="main"><span>]</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>Trueprop</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>SemTyp</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>TY'</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
        </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>varifier</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>NONE</span><span>

      </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>reasoning</span></span><span> </span><span class="entity"><span>phi</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>sequent</span></span><span> </span><span class="main"><span>=</span></span><span>
            </span><span class="entity"><span>default_reasoning</span></span><span> </span><span>true</span><span> </span><span class="entity"><span>default_reasoning_configure</span></span><span> </span><span class="entity"><span>varifier</span></span><span>
                </span><span class="main"><span>(</span></span><span class="entity"><span>exhaustive_PLPR_reasoner</span></span><span> </span><span>NONE</span><span> </span><span class="main"><span>(</span></span><span>K</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>chk_unfolded</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>phi</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>phi</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>sequent</span></span><span>
          </span><span class="comment1"><span>(*|&gt; Phi_Reasoner.reason1 (fn _ =&gt;
                  "Semantic_Type relies on the property of Abstract_Domain<span class="hidden">⇩</span><sub>L</sub>") NONE (SOME 1) ctxt *)</span></span><span>


      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>solver</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>K</span><span> </span><span>NONE</span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>simp</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>is_some</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>#</span></span><span class="inner_numeral"><span>1</span></span><span> </span><span class="entity"><span>instruction</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span>K</span><span> </span><span>I</span><span>
                 </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="entity"><span>simplifier_by_cong</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thms'</span></span><span> </span><a class="entity_ref" href="../../../../../../IDE_CP_App2.html#offset_1267..1281"><span>φTA_SemTy_cong</span></a><span class="antiquote"><span>}</span></span></span></span><span>

      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>thy'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>thy</span></span><span>
              </span><span>|&gt;</span><span> </span><span>Config.put</span><span> </span><span class="entity"><span>Phi_Reasoner.ignore_dup_reasoner</span></span><span> </span><span>true</span><span>
              </span><span>|&gt;</span><span> </span><span class="entity"><span>Bundle.includes</span></span><span> </span><span class="main"><span>[</span></span><span class="inner_quoted"><span>"Spec_Framework.φsem_type_sat_EIF"</span></span><span class="main"><span>]</span></span><span>
              </span><span>|&gt;</span><span> </span><span>Config.restore</span><span> </span><span class="entity"><span>Phi_Reasoner.ignore_dup_reasoner</span></span><span> </span><span class="entity"><span>thy</span></span><span>

      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>rules</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>deriving_framework</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>name</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>parse_hint</span></span><span class="main"><span>,</span></span><span> </span><span>K</span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>guess_property</span></span><span class="main"><span>,</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../../IDE_CP_App2.html#offset_215..229"><span>φTA_SemTy_rule</span></a><span class="antiquote"><span>}</span></span></span></span><span class="main"><span>,</span></span><span>
                                      </span><span class="main"><span>[</span></span><span class="main"><span>(</span></span><span>NONE</span><span class="main"><span>,</span></span><span> </span><span>K</span><span> </span><span class="main"><span>(</span></span><span>K</span><span> </span><span>I</span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span>K</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>pure_PLPR_reasoning</span></span><span> </span><span class="inner_numeral"><span>4</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>
                                       </span><span class="main"><span>(</span></span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>default_ind_inst</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>x</span></span><span class="main"><span>]</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>[</span></span><span>SOME</span><span> </span><span class="entity"><span>x</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span>K</span><span> </span><span>I</span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ind_conv</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>reasoning</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span>
                                      </span><span class="entity"><span>solver</span></span><span class="main"><span>,</span></span><span> </span><span>K</span><span> </span><span>I</span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>simp</span></span><span class="main"><span>)</span></span><span>
                                    </span><span class="entity"><span>phi0</span></span><span> </span><span class="entity"><span>instruction</span></span><span> </span><span class="entity"><span>thy'</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Seq.pull</span><span> </span><span class="entity"><span>rules</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>rule</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>thy</span></span><span>
        </span><span>|&gt;</span><span> </span><span class="entity"><span>note_properties_s</span></span><span> </span><span>false</span><span> </span><span class="entity"><span>phi0</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>(</span></span><span class="entity"><span>name</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>rule</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span>
        </span><span>|&gt;</span><span> </span><span>Local_Theory.declaration</span><span> </span><span class="main"><span>{</span></span><span>syntax</span><span class="main"><span>=</span></span><span>false</span><span class="main"><span>,</span></span><span>pervasive</span><span class="main"><span>=</span></span><span>false</span><span class="main"><span>,</span></span><span> pos </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>#</span></span><span class="inner_numeral"><span>3</span></span><span> </span><span class="entity"><span>instruction</span></span><span class="main"><span>}</span></span><span> </span><span class="main"><span>(</span></span><span>
              </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>m</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Context.mapping</span><span> </span><span class="main"><span>(</span></span><span>Simplifier.map_theory_simpset</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>addsimps</span><span> </span><span class="main"><span>[</span></span><span>Morphism.thm</span><span> </span><span class="entity"><span>m</span></span><span> </span><span class="entity"><span>rule</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
                                      </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>addsimps</span><span> </span><span class="main"><span>[</span></span><span>Morphism.thm</span><span> </span><span class="entity"><span>m</span></span><span> </span><span class="entity"><span>rule</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
               </span><span class="comment1"><span>(* |&gt; Config.map_generic Phi_Reasoner.trace (fn i=&gt;i-1)
                  |&gt; Phi_Reasoner.add_rule (#3 instruction) Phi_Reasoner.TO_BE_OVERRIDE'
                                           (SOME (the_default @{reasoner_group %φsem_type_infer_derived}
                                                              (#2 instruction)))
                                           ([],[]) NONE [Morphism.thm m rule]
                  |&gt; Config.restore_generic Phi_Reasoner.trace lthy *)</span></span><span> </span><span class="main"><span>)</span></span><span>
        </span><span>|&gt;</span><span> </span><span>pair</span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>rule</span></span><span class="main"><span>]</span></span><span>
    </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span class="entity"><span>Automation_Fail</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>[</span></span><span>Pretty.str</span><span> </span><span class="inner_quoted"><span>"Fail to derive any property"</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>semantic_type</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>deriver_framework</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ACCEPT_ONE_HINT</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ONLY_ONCE</span></span><span class="main"><span>,</span></span><span> </span><span class="inner_quoted"><span>"Semantic_Type"</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>gen_semantic_type</span></span><span>

</span><span class="comment1"><span>(*
fun gen_semantic_type (_, name) instruction ctxt (phi : phi_type) thy =
  let val parse_hint = parse_hint (fn <span class="hidden">\&lt;^</span><span class="control">Const</span><span class="hidden">&gt;</span>‹Semantic_Type _› $ T $ _ =&gt; T)
      val ind_conv = K (K I)

      fun varifier _ (Trueprop $ (
                (SemTyp as Const(<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹Semantic_Type›, _) $ _) $ TY
              )) =
            if is_some (#1 instruction)
            then NONE
            else SOME ([TY], fn [TY'] =&gt; Trueprop $ (SemTyp $ TY'))
        | varifier _ X = NONE

      fun reasoning phi ctxt sequent =
            default_reasoning true default_reasoning_configure varifier
                              (exhaustive_PLPR_reasoner NONE (K (chk_unfolded [] ctxt phi))) phi ctxt sequent

      val solver = K NONE
      val simp = K I

      val rules = deriving_framework (name, parse_hint, K [], guess_property false, @{thm' Semantic_Type_derv},
                                      [(SOME (default_ind_inst (fn [x] =&gt; [SOME x]), K I), ind_conv, reasoning)],
                                      solver, K I, simp)
                                    phi instruction ctxt
   in case Seq.pull rules
   of SOME (rule, _) =&gt; thy
        |&gt; note_properties_s false phi [(name, [rule])]
        |&gt; Phi_Help.generic_theory_mapping (#3 instruction) (fn m =&gt;
                  Phi_Reasoner.add_rule (#3 instruction) Phi_Reasoner.TO_BE_OVERRIDE'
                                        (SOME (the_default @{reasoner_group %φsem_type_derived}
                                                           (#2 instruction)))
                                        ([],[]) NONE [Morphism.thm m rule])
        |&gt; pair [rule]
    | _ =&gt; raise Automation_Fail (fn () =&gt; [Pretty.str "Fail to derive any property"])
  end

val strong_semantic_type = deriver_framework (ACCEPT_ONE_HINT, ONLY_ONCE, "Semantic_Type") gen_semantic_type
*)</span></span><span>

</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
</span></pre>
</body>

</html>