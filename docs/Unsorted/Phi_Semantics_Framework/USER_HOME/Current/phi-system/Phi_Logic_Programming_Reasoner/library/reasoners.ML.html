<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>File ‹library/reasoners.ML›</title>
</head>


<body>
<div class="head">
<h1>File ‹library/reasoners.ML›</h1>
</div>

<pre class="source"><span class="keyword1"><span class="keyword"><span>signature</span></span></span><span> </span><span class="entity"><span>PHI_REASONERS</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>sig</span></span></span><span>

  </span><span class="keyword1"><span class="keyword"><span>include</span></span></span><span> </span><span class="entity"><span>PHI_REASONERS</span></span><span>

  </span><span class="keyword1"><span class="keyword"><span>type</span></span></span><span> </span><span class="entity"><span>schm_by_ex</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>int</span><span>
  </span><span class="comment1"><span>(*whether to replace schematic variables by existential quantified variables if feasible.
      0: do not generate existence in obligations, leaving them schematic variables, so this feature
         is disabled at all.
      1: generate existences in obligations, which are given at the beginning the obligations.
      2: generate existences in obligations and try to push them over (⟶, ∧) to the bottom.
         This pushing is done by the mechanism of special existences (∃<span class="hidden">⇧</span><sup>φ</sup><span class="hidden">⇧</span><sup>-</sup><span class="hidden">⇧</span><sup>L</sup><span class="hidden">⇧</span><sup>P</sup><span class="hidden">⇧</span><sup>R</sup>).
      ~1: take ‹Config.get existential_obligation› *)</span></span><span>

  </span><span class="keyword1"><span class="keyword"><span>type</span></span></span><span> </span><span class="entity"><span>contraction_mode</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>bool</span><span> * </span><span>bool</span><span> * </span><span class="entity"><span>schm_by_ex</span></span><span>
  </span><span class="comment1"><span>(*contraction_mode = (collect_premises, conv_all, schm_by_ex)

    collect_premises: whether to collect premises into the reported proof oblgiation
    conv_all: whether to convert all meta-all into hol-all inside the reported obligation *)</span></span><span>

  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> collect_obligation_premises </span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>contraction_mode</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>
                                 </span><span class="main"><span>-&gt;</span></span><span> </span><span>int</span><span> </span><span class="comment1"><span>(*number of new conditions introduced*)</span></span><span> * </span><span>thm</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> obligation_intro_Ex_conv </span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>schm_by_ex</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>

  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> auto_obligation_solver </span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span>Seq.seq</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> auto_obligation_solver' </span><span class="main"><span>:</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>(*failure callback*)</span></span><span>
                              </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> auto_obligation_solver1 </span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>

  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> guard_condition_solver </span><span class="main"><span>:</span></span><span> </span><span class="main"><span>{</span></span><span>can_inst</span><span class="main"><span>:</span></span><span> </span><span>bool</span><span class="main"><span>}</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span>Seq.seq</span><span>
      </span><span class="comment1"><span>(*The annotation of ‹case_split› is supported*)</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> guard_condition_solver'</span><span class="main"><span>:</span></span><span> </span><span class="main"><span>{</span></span><span>can_inst</span><span class="main"><span>:</span></span><span> </span><span>bool</span><span class="main"><span>}</span></span><span>
                             </span><span class="main"><span>-&gt;</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>(*failure callback*)</span></span><span>
                             </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> guard_condition_solver1</span><span class="main"><span>:</span></span><span> </span><span class="main"><span>{</span></span><span>can_inst</span><span class="main"><span>:</span></span><span> </span><span>bool</span><span class="main"><span>}</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>

  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> safe_obligation_solver </span><span class="main"><span>:</span></span><span> </span><span class="main"><span>{</span></span><span>can_inst</span><span class="main"><span>:</span></span><span> </span><span>bool</span><span class="main"><span>}</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span>Seq.seq</span><span>
      </span><span class="comment1"><span>(*The annotation of ‹case_split› is supported*)</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> safe_obligation_solver'</span><span class="main"><span>:</span></span><span> </span><span class="main"><span>{</span></span><span>can_inst</span><span class="main"><span>:</span></span><span> </span><span>bool</span><span class="main"><span>}</span></span><span>
                             </span><span class="main"><span>-&gt;</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>(*failure callback*)</span></span><span>
                             </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> safe_obligation_solver1</span><span class="main"><span>:</span></span><span> </span><span class="main"><span>{</span></span><span>can_inst</span><span class="main"><span>:</span></span><span> </span><span>bool</span><span class="main"><span>}</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>


  </span><span class="comment1"><span>(*defer the leading antecedent to the nearest obligation and call the contract*)</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> defer_obligation </span><span class="main"><span>:</span></span><span> </span><span class="main"><span>{</span></span><span>can_inst</span><span class="main"><span>:</span></span><span>bool</span><span class="main"><span>,</span></span><span> fix_level</span><span class="main"><span>:</span></span><span>int</span><span class="main"><span>}</span></span><span>
                      </span><span class="main"><span>-&gt;</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span class="main"><span>)</span></span><span> </span><span class="comment1"><span>(*contract*)</span></span><span>
                      </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span>Seq.seq</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> defer_obligation_tac </span><span class="main"><span>:</span></span><span> </span><span class="main"><span>{</span></span><span>can_inst</span><span class="main"><span>:</span></span><span>bool</span><span class="main"><span>,</span></span><span> fix_level</span><span class="main"><span>:</span></span><span>int</span><span class="main"><span>}</span></span><span>
                          </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>contraction_mode</span></span><span>
                          </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span>Seq.seq</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> augment_conditions </span><span class="main"><span>:</span></span><span> </span><span>thm</span><span> </span><span>list</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>
        </span><span class="comment1"><span>(*augmenting conditions to the leading proof obligations*)</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> has_obligations_tag </span><span class="main"><span>:</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>bool</span><span>


  </span><span class="keyword1"><span class="keyword"><span>structure</span></span></span><span> Tactic_Configures </span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>HOOKS</span></span><span> </span><span class="comment1"><span>(*You can alter auxiliary facts, tactics, and configure the
      context before applying either the automatic solving*)</span></span><span>

</span><span class="comment1"><span>(*  val extract_prem  : Context.generic -&gt; bool (*strip the Premise tag or not*) -&gt; thm -&gt; thm option
  val extract_prems : Context.generic -&gt; bool (*strip the Premise tag or not*) -&gt; thm -&gt; thm list
  val extract_prems_rewr : Proof.context -&gt; cterm -&gt; thm option option*)</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> is_syntactic_premise </span><span class="main"><span>:</span></span><span> </span><span>term</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>bool</span><span>

  </span><span class="comment1"><span>(*(* Simplifications that uses the extracted premises.
     The boolean: use_origin. if not use_origin, drops the original premises
     and only remains the extracted premises.*)*)</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> asm_simplify </span><span class="main"><span>:</span></span><span> </span><span>bool</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> asm_lr_simplify </span><span class="main"><span>:</span></span><span> </span><span>bool</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> full_simplify </span><span class="main"><span>:</span></span><span> </span><span>bool</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>thm</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> asm_simp_tac </span><span class="main"><span>:</span></span><span> </span><span>bool</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>int</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>tactic</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> asm_lr_simp_tac </span><span class="main"><span>:</span></span><span> </span><span>bool</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>int</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>tactic</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> asm_rewrite </span><span class="main"><span>:</span></span><span> </span><span>bool</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>conv</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> asm_lr_rewrite </span><span class="main"><span>:</span></span><span> </span><span>bool</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>conv</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> asm_full_rewrite </span><span class="main"><span>:</span></span><span> </span><span>bool</span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span class="entity"><span>Proof.context</span></span><span> </span><span class="main"><span>-&gt;</span></span><span> </span><span>conv</span><span>

  </span><span class="comment1"><span>(*structure Is_Premise_of_Obligation : HANDLERS
      (*Tell me what antecedents are considered premise of a proof obligation to be reported,
        and what are not so that to be ignored.*)*)</span></span><span>
  </span><span class="comment1"><span>(*val is_premise_of_obligation : (*Context.generic -&gt;*) term -&gt; bool*)</span></span><span>

  </span><span class="comment1"><span>(*structure Local_Premises_of_Obligation : NAMED_THMS
      (*You can add any facts to be reported as premises of a proof obligation*)*)</span></span><span>

</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>


</span><span class="keyword1"><span class="keyword"><span>structure</span></span></span><span> </span><span class="entity"><span>Phi_Reasoners</span></span><span> </span><span class="main"><span>:</span></span><span> </span><span class="entity"><span>PHI_REASONERS</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>struct</span></span></span><span>
</span><span class="keyword3"><span class="keyword"><span>open</span></span></span><span> </span><span>Thm</span><span> </span><span>Term</span><span> </span><span>Phi_Reasoners</span><span>

</span><span class="comment1"><span>(** Preliminary **)</span></span><span>


</span><span class="comment1"><span>(*fun print_dbg' th = Seq.make (fn () =&gt; (@{print} th; NONE))
fun print_dbg prompt th = Seq.make (fn () =&gt; (@{print} prompt; @{print} th; SOME (th, Seq.empty))) *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>aux_thms</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Useful_Thms.get</span></span><span>


</span><span class="comment1"><span>(* Simple Simplification of Obligations Before Exporting *)</span></span><span>
</span><span class="comment1"><span>(*to see if it can be reduced to some trivial form like ‹A = ?x›*)</span></span><span>

</span><span class="comment1"><span>(*
val conv_LRHS_heads = [<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹id›, <span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹fst›, <span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹snd›]
fun conv_LRHS ctm =
  case Thm.term_of ctm
    of Const(<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹id›, _) $ _ =&gt;
          Conv.rewr_conv @{thm' Fun.id_apply[folded atomize_eq]} ctm
     | Const(<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹fst›, _) $ (Const(<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹Pair›, _) $ _ $ _) =&gt;
          Conv.rewr_conv @{thm' Product_Type.fst_conv[folded atomize_eq]} ctm
     | Const(<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹snd›, _) $ (Const(<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹Pair›, _) $ _ $ _) =&gt;
          Conv.rewr_conv @{thm' Product_Type.snd_conv[folded atomize_eq]} ctm
     | Const(<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹case_prod›, _) $ _ $ (Const(<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹Pair›, _) $ _ $ _) =&gt;
          Conv.rewr_conv @{thm' prod.case[folded atomize_eq]} ctm
     | _ =&gt; raise CTERM ("conv_LRHS", [ctm])

fun need_conv_LRHS tm =
  case Term.head_of tm of Const(N, _) =&gt; member (op =) conv_LRHS_heads N
                        | _ =&gt; false

fun simple_simp ctxt sequent =
  case PLPR_Syntax.dest_premise_tag (major_prem_of sequent)
    of (_, Const(<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹HOL.eq›, _) $ X $ Y) =&gt;
         if need_conv_LRHS X orelse need_conv_LRHS Y
         then Conv.gconv_rule (Phi_Conv.hhf_concl_conv (fn _ =&gt;
                 Conv.arg_conv (Conv.arg_conv (
                      HOLogic.eq_conv (Conv.repeat_conv conv_LRHS) (Conv.repeat_conv conv_LRHS)))
                 ) ctxt
              ) 1 sequent
         else sequent
     | _ =&gt; sequent
*)</span></span><span>

</span><span class="comment1"><span>(*** Tactics ***)</span></span><span>

</span><span class="comment1"><span>(** Tactic Configures **)</span></span><span>
</span><span class="comment1"><span>(*depreciate?*)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>datatype</span></span></span><span> </span><span class="entity"><span>solver_mode</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Agressive_Solver</span></span><span> </span><span class="comment1"><span>(*the auto method*)</span></span><span> </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>Safe_Solver</span></span><span> </span><span class="comment1"><span>(*by clarsimp*)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>structure</span></span></span><span> </span><span class="entity"><span>Tactic_Configures</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Hooks</span></span><span> </span><span class="main"><span>(</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>type</span></span></span><span> </span><span class="entity"><span>arg</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>solver_mode</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>type</span></span></span><span> </span><span class="entity"><span>state</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>thm</span><span> </span><span>list</span><span> </span><span class="comment1"><span>(*aux thms*)</span></span><span> * </span><span>tactic</span><span> * </span><span class="entity"><span>Proof.context</span></span><span>
</span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>apply_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>tactic</span></span><span> </span><span class="entity"><span>mode</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span>HEADGOAL</span><span> </span><span class="main"><span>(</span></span><span>SOLVED'</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>tac</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>#</span></span><span class="inner_numeral"><span>2</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Tactic_Configures.invoke_until_success</span></span><span> </span><span class="main"><span>(</span></span><span>Context.Proof</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span>
          </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>mode</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>aux</span></span><span class="main"><span>,</span></span><span class="entity"><span>tac</span></span><span class="main"><span>,</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
              </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>tactic</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>tac</span></span><span class="main"><span>,</span></span><span class="entity"><span>aux</span></span><span class="main"><span>,</span></span><span class="entity"><span>mode</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>mode</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>aux_thms</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span> </span><span>all_tac</span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
     </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>tac</span></span><span> </span><span class="entity"><span>th</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span> </span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>

</span><span class="comment1"><span>(*
(** Tactic Template **)

structure Very_Safe_Oblg_Simp_SS = Simpset(
  val initial_ss = Simpset_Configure.Minimal_SS_configure (fn ctxt =&gt;
                      ctxt addsimps @{thms' HOL.simp_thms})
  val binding = NONE
  val attribute = NONE
  val comment = "Very safe rewrite rules normalizing proof obligations"
  val post_merging = I
)*)</span></span><span>

</span><span class="comment1"><span>(** Annot of Fixing **)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>annot_of_fixing</span></span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.LPR_ctrl|const"><span>LPR_ctrl</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Term.add_vars</span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="entity"><span>ret</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>annot_of_fixing</span></span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>A</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>B</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>annot_of_fixing</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>annot_of_fixing</span></span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="entity"><span>A</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>B</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>annot_of_fixing</span></span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="main"><span>(</span></span><span>Abs</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>annot_of_fixing</span></span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="entity"><span>X</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>annot_of_fixing</span></span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>ret</span></span><span>

</span><span class="comment1"><span>(*Eliminating unknown variables as early as possible is essential for the performance of solving
proof obligations. It seems that Isabelle is not very good at eliminating existentially quantified
variables (to which unknown variables will be instantiate) and fails sometimes even for naive instantiation.
Therefore, we use sophisticated instantiation strategy here involving different levels of
computational complexity to instantiate them as early as possible.*)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>mk_boolean_inst</span></span><span> </span><span class="main"><span>(</span></span><span>Var</span><span> </span><span class="entity"><span>v</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>b</span></span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Vars.add</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>v</span></span><span class="main"><span>,</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>b</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="entity"><span>Phi_Help.True</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="entity"><span>Phi_Help.False</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ret</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>mk_boolean_inst</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.conj|const"><span>HOL.conj</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>A</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>B</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>b</span></span><span> </span><span class="entity"><span>ret</span></span><span>
      </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>mk_boolean_inst</span></span><span> </span><span class="entity"><span>B</span></span><span> </span><span class="entity"><span>b</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>mk_boolean_inst</span></span><span> </span><span class="entity"><span>A</span></span><span> </span><span class="entity"><span>b</span></span><span> </span><span class="entity"><span>ret</span></span><span class="main"><span>)</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>mk_boolean_inst</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.Not|const"><span>HOL.Not</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>A</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>b</span></span><span> </span><span class="entity"><span>ret</span></span><span>
      </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>mk_boolean_inst</span></span><span> </span><span class="entity"><span>A</span></span><span> </span><span class="main"><span>(</span></span><span>not</span><span> </span><span class="entity"><span>b</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ret</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>mk_boolean_inst</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/Fun.html#Fun.id|const"><span>id</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>b</span></span><span> </span><span class="entity"><span>ret</span></span><span>
      </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>mk_boolean_inst</span></span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="entity"><span>b</span></span><span> </span><span class="entity"><span>ret</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>mk_boolean_inst</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span>Match</span><span>

</span><span class="comment1"><span>(*it is unsafe to instantiate any functional unknown variable because you don't know how
  the function would be and it may be even not unique. For example, ‹?x a b = True›, you
  may think the instantiation would be ‹λ_ _. True› but it actually can also be ‹λa b. a = b›
  when ‹a = b›.

  However, even if it is unsafe, it works in most of cases and our simplifier tactics are already
  unsafe. The unsafe instantiation is still acceptable once users can use tags to prevent aggressive
  instantiation.

  TODO: I don't know if we should re-enable IEUV but I believe the procedure of IEUV should be hard-coded
    in the fast_inst below.
*)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>is_var'</span></span><span> </span><span class="entity"><span>vars</span></span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Term.strip_comb</span><span> </span><span class="entity"><span>x</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span class="main"><span>(</span></span><span>Var</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>v</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>args</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>forall</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span>Bound</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>true</span><span> </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>false</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>args</span></span><span> </span><span class="keyword1"><span class="keyword"><span>andalso</span></span></span><span>
                            </span><span>not</span><span> </span><span class="main"><span>(</span></span><span>member</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>op</span></span></span><span> </span><span class="main"><span>=</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>vars</span></span><span> </span><span class="entity"><span>v</span></span><span class="main"><span>)</span></span><span>
     </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>false</span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>fast_inst</span></span><span> </span><span class="entity"><span>can_inst</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>vars</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>fold</span><span> </span><span class="main"><span>(</span></span><span>Term.add_var_names</span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Logic.strip_assums_hyp</span><span> </span><span class="main"><span>(</span></span><span>hd</span><span> </span><span class="main"><span>(</span></span><span>Thm.prems_of</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>can_inst</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>PLPR_Syntax.may_dest_premise_tag</span></span><span> </span><span class="main"><span>(</span></span><span>major_prem_of</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span>Const</span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
            </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise_True|fact"><span>Premise_True</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>,</span></span><span> </span><span>Seq.empty</span><span class="main"><span>)</span></span><span>
     </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>(</span></span><span>true</span><span class="main"><span>,</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.Not|const"><span>HOL.Not</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
         </span><span class="main"><span>(</span></span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span>Thm.instantiate</span><span> </span><span class="main"><span>(</span></span><span>TVars.empty</span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>mk_boolean_inst</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Help.beta_eta_contract_term</span></span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span> </span><span>false</span><span> </span><span>Vars.empty</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>,</span></span><span>
                </span><span>Seq.empty</span><span class="main"><span>)</span></span><span>
          </span><span class="keyword3"><span class="keyword"><span>handle</span></span></span><span> </span><span>Match</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>NONE</span><span class="main"><span>)</span></span><span>
     </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>(</span></span><span>true</span><span class="main"><span>,</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.conj|const"><span>HOL.conj</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span>
                    </span><span>$</span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.eq|const"><span>HOL.eq</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>X</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>Y</span></span><span class="main"><span>)</span></span><span>
                    </span><span>$</span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
         </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>is_var'</span></span><span> </span><span class="entity"><span>vars</span></span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="keyword1"><span class="keyword"><span>orelse</span></span></span><span> </span><span class="entity"><span>is_var'</span></span><span> </span><span class="entity"><span>vars</span></span><span> </span><span class="entity"><span>Y</span></span><span>
         </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="main"><span>(</span></span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>lemma'</span></span><span> </span><span class="quoted"><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>x</span></span><span> </span><span class="main"><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="free"><span>x</span></span><span> </span><span class="main"><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.conj|const"><span>∧</span></a></span><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span>›</span></span><span>
                     </span><span class="quasi_keyword"><span>by</span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span>:</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise_def|fact"><span>Premise_def</span></a><span class="main"><span>)</span></span><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>,</span></span><span> </span><span>Seq.empty</span><span class="main"><span>)</span></span><span>
               </span><span class="keyword3"><span class="keyword"><span>handle</span></span></span><span> </span><span>THM</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>NONE</span><span class="main"><span>)</span></span><span>
         </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span>NONE</span><span>
     </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>(</span></span><span>true</span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="keyword1"><span class="keyword"><span>as</span></span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.conj|const"><span>HOL.conj</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
         </span><span class="main"><span>(</span></span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span>Thm.instantiate</span><span> </span><span class="main"><span>(</span></span><span>TVars.empty</span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>mk_boolean_inst</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Help.beta_eta_contract_term</span></span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span> </span><span>false</span><span> </span><span>Vars.empty</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>,</span></span><span>
                </span><span>Seq.empty</span><span class="main"><span>)</span></span><span>
          </span><span class="keyword3"><span class="keyword"><span>handle</span></span></span><span> </span><span>Match</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>NONE</span><span class="main"><span>)</span></span><span>
     </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>(</span></span><span>true</span><span class="main"><span>,</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.eq|const"><span>HOL.eq</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>X</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>Y</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
         </span><span class="comment1"><span>(*solves the equation by unification once single resolution*)</span></span><span>
         </span><span class="comment1"><span>(*TODO, BUG: ant ‹fst (fst x, undefined) = fst ?x› results in single unification ‹x &lt;- (fst x, undefined)›*)</span></span><span>
         </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>is_var'</span></span><span> </span><span class="entity"><span>vars</span></span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="keyword1"><span class="keyword"><span>orelse</span></span></span><span> </span><span class="entity"><span>is_var'</span></span><span> </span><span class="entity"><span>vars</span></span><span> </span><span class="entity"><span>Y</span></span><span>
         </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="main"><span>(</span></span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>lemma'</span></span><span> </span><span class="quoted"><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>x</span></span><span> </span><span class="main"><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.eq|const"><span>=</span></a></span><span> </span><span class="free"><span>x</span></span><span class="main"><span>)</span></span><span>›</span></span><span> </span><span class="quasi_keyword"><span>by</span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span>:</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise_def|fact"><span>Premise_def</span></a><span class="main"><span>)</span></span><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>,</span></span><span> </span><span>Seq.empty</span><span class="main"><span>)</span></span><span>
               </span><span class="keyword3"><span class="keyword"><span>handle</span></span></span><span> </span><span>THM</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>NONE</span><span class="main"><span>)</span></span><span>
         </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span>NONE</span><span>
     </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>(</span></span><span>true</span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>is_Var</span><span> </span><span class="main"><span>(</span></span><span>Term.head_of</span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise_True|fact"><span>Premise_True</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>,</span></span><span> </span><span>Seq.empty</span><span class="main"><span>)</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span>NONE</span><span>
     </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>NONE</span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="comment1"><span>(*slow but powerfull and flexible*)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>LPR_inst</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span> </span><span class="comment1"><span>(*TODO: strengthen fast_inst*)</span></span><span>
  </span><span class="comment1"><span>(*if Term.is_schematic (Thm.major_prem_of th)
  then (
    Phi_Reasoner.info_print ctxt 3 (fn () =&gt; "Phi_Reasoners.LPR_inst") ;
    Phi_Reasoner.reason NONE (SOME 1) ctxt
                        (@{lemma' ‹ 𝗀𝗎𝖺𝗋𝖽 IEUV Any False P P' ∧<span class="hidden">⇩</span><sub>𝗋</sub> Literal_Boolean Any
                                ⟹ Premise mode P'
                                ⟹ Premise mode P ›
                               by (simp add: IEUV_def 𝗋Guard_def Ant_Seq_def)
                          } RS' (ctxt, th)) )
  else*)</span></span><span> </span><span>NONE</span><span>
</span><span class="main"><span>)</span></span><span>

</span><span class="comment1"><span>(*fix_level = 0 for no fix
            | 1 for fixing the conditions of the leading antecedent only but leaves variables
                    in the conclusion of the leading antecedent free
            | 2 for fixing variables in the entire leading antecedent*)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>oblg_template</span></span><span> </span><span class="entity"><span>report_time</span></span><span> </span><span class="main"><span>{</span></span><span class="entity"><span>can_inst</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>fix_level</span></span><span class="main"><span>}</span></span><span> </span><span class="entity"><span>f</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>th00</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
  </span><span class="entity"><span>PLPR_Statistics.measure_time_of_proof_evaluation'</span></span><span> </span><span class="entity"><span>report_time</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>th01</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>PLPR_Syntax.dest_premise_tag_opt</span></span><span> </span><span class="main"><span>(</span></span><span>major_prem_of</span><span> </span><span class="entity"><span>th00</span></span><span class="main"><span>)</span></span><span>
                   </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>th00</span></span><span>
                    </span><span class="main"><span>|</span></span><span> </span><span>NONE</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise_D|fact"><span>Premise_D</span></a><span class="main"><span>[</span></span><a class="entity_ref" href="../../../../../ISABELLE_HOME/src/HOL/Eisbach/eisbach_rule_insts.ML.html#Eisbach.where|attribute"><span class="operator"><span>where</span></span></a><span> mode</span><span class="main"><span class="main"><span>=</span></span></span><span class="quoted"><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.default|const"><span>default</span></a></span><span class="main"><span>]</span></span><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>th00</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Conv.gconv_rule</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Conv.hhf_concl_conv</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
              </span><span class="entity"><span>PLPR_Syntax.premise_tag_conv</span></span><span> </span><span class="main"><span>(</span></span><span>K</span><span> </span><span>true</span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Simplifier.full_rewrite</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="entity"><span>th01</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Thm.major_prem_of</span><span> </span><span class="entity"><span>th</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.TrueI|fact"><span>TrueI</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span class="entity"><span>RS'</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span>Seq.empty</span><span class="main"><span>)</span></span><span>
    </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>fast_inst</span></span><span> </span><span class="entity"><span>can_inst</span></span><span> </span><span class="entity"><span>th</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>SOME</span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>SOME</span><span> </span><span class="entity"><span>ret</span></span><span>
    </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="comment1"><span>(* simple_simp ctxt (Conv.gconv_rule (Phi_Conv.hhf_concl_conv (fn ctxt =&gt;
                HOLogic.Trueprop_conv (Conv.arg_conv (
                  Simplifier.rewrite (Very_Safe_Oblg_Simp_SS.equip ctxt)))
             ) ctxt) 1 th01) *)</span></span><span>

      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="entity"><span>prems</span></span><span class="main"><span>,</span></span><span class="entity"><span>concl</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Phi_Help.leading_antecedent</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.prop_of</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>annotated_fixs</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>annot_of_fixing</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span> </span><span class="entity"><span>concl</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>fixing_targets</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>map</span><span> </span><span>Var</span><span> </span><span class="main"><span>(</span></span><span>
             </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>fix_level</span></span><span>
               </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>merge</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>op</span></span></span><span> </span><span class="main"><span>=</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>subtract</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>op</span></span></span><span> </span><span class="main"><span>=</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>add_vars</span><span> </span><span class="entity"><span>concl</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>fold</span><span> </span><span>add_vars</span><span> </span><span class="entity"><span>prems</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>
                                     </span><span class="entity"><span>annotated_fixs</span></span><span class="main"><span>)</span></span><span>
                </span><span class="main"><span>|</span></span><span> </span><span class="inner_numeral"><span>2</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>add_vars</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Help.leading_antecedent'</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>annotated_fixs</span></span><span>
                </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>annotated_fixs</span></span><span> </span><span class="main"><span>)</span></span><span>

      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt'</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>th2</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>instc</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span>
            </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>null</span><span> </span><span class="entity"><span>fixing_targets</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span>TVars.empty</span><span class="main"><span>,</span></span><span> </span><span>Vars.empty</span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
            </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>inst</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ctxt'</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Variable.import_inst</span><span> </span><span>false</span><span> </span><span class="entity"><span>fixing_targets</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
                     </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>instc</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Phi_Help.certify_vars</span></span><span> </span><span class="main"><span>(</span></span><span>Context.Proof</span><span> </span><span class="entity"><span>ctxt'</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>inst</span></span><span>
                  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt'</span></span><span class="main"><span>,</span></span><span> </span><span>Thm.instantiate</span><span> </span><span class="entity"><span>instc</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>instc</span></span><span class="main"><span>)</span></span><span>
                 </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
                    
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>fast_inst</span></span><span> </span><span class="entity"><span>can_inst</span></span><span> </span><span class="entity"><span>th2</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>SOME</span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>SOME</span><span> </span><span class="entity"><span>ret</span></span><span>
    </span><span class="main"><span>|</span></span><span> </span><span>NONE</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>(</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>LPR_inst</span></span><span> </span><span class="entity"><span>ctxt'</span></span><span> </span><span class="entity"><span>th2</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>SOME</span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>f</span></span><span> </span><span class="entity"><span>ctxt'</span></span><span> </span><span class="entity"><span>ret</span></span><span>
         </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>f</span></span><span> </span><span class="entity"><span>ctxt'</span></span><span> </span><span class="entity"><span>th2</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
   </span><span>|&gt;</span><span> </span><span>not</span><span> </span><span class="main"><span>(</span></span><span>null</span><span> </span><span class="entity"><span>fixing_targets</span></span><span class="main"><span>)</span></span><span> </span><span>?</span><span> </span><span>Option.map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>th</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>seq'</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>f</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>singleton</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Variable.export_inst</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Help.uncertify_vars</span></span><span> </span><span class="entity"><span>instc</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
         </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>f</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>,</span></span><span> </span><span>Seq.map</span><span> </span><span class="entity"><span>f</span></span><span> </span><span class="entity"><span>seq'</span></span><span class="main"><span>)</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>


</span><span class="comment1"><span>(*** Auxiliaries ***)</span></span><span>

</span><span class="comment1"><span>(*protects the remaining goals and only attack the first one*)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>head_only</span></span><span> </span><span class="entity"><span>tac</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>Thm.nprems_of</span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="inner_numeral"><span>0</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span>all_tac</span><span> </span><span class="entity"><span>th</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span>Goal.protect</span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span>|&gt;</span><span> </span><span class="entity"><span>tac</span></span><span> </span><span>|&gt;</span><span> </span><span>Seq.map</span><span> </span><span>Goal.conclude</span><span>


</span><span class="comment1"><span>(*Wrap a context tactic of type `Proof.context -&gt; thm -&gt; thm Seq.seq` to the
  transition between states, of type `Proof.context * thm -&gt; Proof.context * thm`.
  *This wrap only adopts the first result of applying the tactic, and drops other alternatives.*
  The original seq-based tactics are not affected by this.

  Because reasoners in the file only attack the first antecedent and solves it totally or fails,
  this short-cut makes differences only when the antecedent to be solved has some schematic variables
  to be instantiated during the tactic application.

  The semantics of schematic variables in auto_obligation_solver and guard_condition_solver is,
  any possible instantiation is acceptable.

  If the schematic variables are not able to be chosen arbitrarily, additional mechanisms have
  to be applied previously.*)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>context_tactic_to_state_transition</span></span><span> </span><span class="entity"><span>tac</span></span><span> </span><span class="entity"><span>fail</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>sequent</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Seq.pull</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>th'</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>th'</span></span><span>
     </span><span class="main"><span>|</span></span><span> </span><span>NONE</span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>fail</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>sequent</span></span><span>

</span><span class="comment1"><span>(*fun context_tactic_to_state_transition_opt tac (ctxt, sequent) =
  case Seq.pull (tac ctxt sequent)
    of SOME (th', _) =&gt; SOME (ctxt, th')
     | NONE =&gt; NONE *)</span></span><span>


</span><span class="comment1"><span>(** Case Split **)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>case_split_by_annotations</span></span><span> </span><span class="entity"><span>term</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>insrt</span></span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="entity"><span>splits</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>Term.is_open</span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="entity"><span>splits</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span>insert</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>op</span></span></span><span> </span><span>aconv</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="entity"><span>splits</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>parse_split</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="entity"><span>N</span></span><span class="main"><span>,</span></span><span> </span><span>Type</span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"fun"</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>T</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>splits</span></span><span> </span><span class="main"><span>=</span></span><span>
            </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>N</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.case_split|const"><span>case_split</span></a><span>›</span></span><span> </span><span class="keyword1"><span class="keyword"><span>orelse</span></span></span><span> </span><span class="entity"><span>N</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.LPR_ctrl|const"><span>LPR_ctrl</span></a><span>›</span></span><span>
            </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>T</span></span><span class="main"><span>,</span></span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span>
              </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Type</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/Product_Type.html#Product_Type.prod|type"><span>prod</span></a><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>_</span></span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/Product_Type.html#Product_Type.Pair|const"><span>Pair</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>splits</span></span><span>
               </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Type</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/Product_Type.html#Product_Type.prod|type"><span>prod</span></a><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>_</span></span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>x</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>insrt</span></span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="entity"><span>splits</span></span><span>
               </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Type</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.True|const"><span>True</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>splits</span></span><span>
               </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Type</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.False|const"><span>False</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>splits</span></span><span>
               </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Type</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.bool|type"><span>bool</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>x</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>insrt</span></span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="entity"><span>splits</span></span><span>
               </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Type</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/Sum_Type.html#Sum_Type.sum|type"><span>sum</span></a><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>_</span></span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/Sum_Type.html#Sum_Type.Inl|const"><span>Inl</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>splits</span></span><span>
               </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Type</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/Sum_Type.html#Sum_Type.sum|type"><span>sum</span></a><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>_</span></span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/Sum_Type.html#Sum_Type.Inr|const"><span>Inr</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>splits</span></span><span>
               </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Type</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/Sum_Type.html#Sum_Type.sum|type"><span>sum</span></a><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>_</span></span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>x</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>insrt</span></span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="entity"><span>splits</span></span><span>
               </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>insrt</span></span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="entity"><span>splits</span></span><span class="main"><span>)</span></span><span>
            </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="entity"><span>parse_split</span></span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="entity"><span>splits</span></span><span>
       </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>parse_split</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>A</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>B</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>splits</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>parse_split</span></span><span> </span><span class="entity"><span>B</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>parse_split</span></span><span> </span><span class="entity"><span>A</span></span><span> </span><span class="entity"><span>splits</span></span><span class="main"><span>)</span></span><span>
       </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>parse_split</span></span><span> </span><span class="main"><span>(</span></span><span>Abs</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>splits</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>parse_split</span></span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="entity"><span>splits</span></span><span>
       </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>parse_split</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="entity"><span>splits</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>splits</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>parse_split</span></span><span> </span><span class="entity"><span>term</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>K</span><span> </span><span class="main"><span>(</span></span><span>K</span><span> </span><span>all_tac</span><span class="main"><span>)</span></span><span>
    </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>L</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>goal</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>st</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                  </span><span>foldl1</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>op</span></span></span><span> </span><span>THEN_ALL_NEW</span><span class="main"><span>)</span></span><span>
                         </span><span class="main"><span>(</span></span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>tm</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>DETERM</span><span> </span><span>o</span><span> </span><span class="entity"><span>Induct.cases_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>true</span><span> </span><span class="main"><span>[</span></span><span class="main"><span>[</span></span><span>SOME</span><span> </span><span class="entity"><span>tm</span></span><span class="main"><span>]</span></span><span class="main"><span>]</span></span><span> </span><span>NONE</span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>L</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>goal</span></span><span> </span><span class="entity"><span>st</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>case_split_by_annotations_leading_subgoal</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>goal</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="entity"><span>case_split_by_annotations</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Help.leading_antecedent'</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>goal</span></span><span> </span><span class="entity"><span>th</span></span><span>
  

</span><span class="comment1"><span>(*** Obligation Extraction ***)</span></span><span>

</span><span class="comment1"><span>(** Premise Extraction **)</span></span><span>

</span><span class="comment1"><span>(*Given any antecedent, if we can extract abstract pure facts that can help to solve the target
  proof obligation?*)</span></span><span>
</span><span class="comment1"><span>(*Convention: the rule of premise extraction has form ‹A ≡ Premise ∧ A›*)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>type</span></span></span><span> </span><span class="entity"><span>pattern</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>term</span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>is_syntactic_premise_mode</span></span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.MODE_GUARD|const"><span>MODE_GUARD</span></a><span>›</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>true</span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_syntactic_premise_mode</span></span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.NO_INST|const"><span>NO_INST</span></a><span>›</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>true</span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_syntactic_premise_mode</span></span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.MODE_COLLECT|const"><span>MODE_COLLECT</span></a><span>›</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>true</span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_syntactic_premise_mode</span></span><span> </span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.default|const"><span>default</span></a><span>›</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>true</span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_syntactic_premise_mode</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>false</span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise|const"><span>Premise</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="entity"><span>M</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>is_syntactic_premise_mode</span></span><span> </span><span class="entity"><span>M</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="main"><span>(</span></span><span>Abs</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="entity"><span>X</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="entity"><span>X</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><span>Pure.imp</span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="entity"><span>X</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><span>Pure.all</span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="entity"><span>X</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.All|const"><span>HOL.All</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="entity"><span>X</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.implies|const"><span>HOL.implies</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="entity"><span>X</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>false</span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>strip_premise_tag</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>ctm</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Thm.term_of</span><span> </span><span class="entity"><span>ctm</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise|const"><span>Premise</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span>Conv.try_conv</span><span> </span><span class="main"><span>(</span></span><span>Conv.rewrs_conv</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thms'</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise_def|fact"><span>Premise_def</span></a><span class="antiquote"><span>}</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctm</span></span><span>
     </span><span class="main"><span>|</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span>Conv.arg_conv</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>strip_premise_tag</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctm</span></span><span>
     </span><span class="main"><span>|</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.implies|const"><span>HOL.implies</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span>Conv.combination_conv</span><span> </span><span class="main"><span>(</span></span><span>Conv.arg_conv</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>strip_premise_tag</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>strip_premise_tag</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctm</span></span><span>
     </span><span class="main"><span>|</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.All|const"><span>HOL.All</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span class="entity"><span>Phi_Conv.hol_all_conv</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>strip_premise_tag</span></span><span> </span><span>o</span><span> </span><span>snd</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>ctm</span></span><span>
     </span><span class="main"><span>|</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.conj|const"><span>HOL.conj</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span>Conv.combination_conv</span><span> </span><span class="main"><span>(</span></span><span>Conv.arg_conv</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>strip_premise_tag</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>strip_premise_tag</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctm</span></span><span>
     </span><span class="main"><span>|</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Ant_Seq|const"><span>Ant_Seq</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span>Conv.combination_conv</span><span> </span><span class="main"><span>(</span></span><span>Conv.arg_conv</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>strip_premise_tag</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>strip_premise_tag</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctm</span></span><span>
     </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Conv.all_conv</span><span> </span><span class="entity"><span>ctm</span></span><span>

</span><span class="comment1"><span>(*
fun extract_prem ctxt strip =
  let val ctxt' = Context.proof_of ctxt
   in fn thm =&gt;
   if is_syntactic_premise (Thm.prop_of thm)
   then SOME (if strip
              then (Raw_Simplifier.norm_hhf ctxt' thm)
                |&gt; Conv.fconv_rule (strip_premise_tag ctxt')
              else thm)
   else (*if qchk [] (Thm.prop_of thm)
        then let val thm = Raw_Simplifier.norm_hhf ctxt' thm
              in (case conv ctxt' (Thm.cprop_of thm)
                    of SOME NONE =&gt; SOME (if strip
                                          then Conv.fconv_rule (strip_premise_tag ctxt') thm
                                          else thm)
                     | SOME (SOME rule) =&gt; SOME (
                         (Thm.equal_elim rule thm RS' (ctxt', conjunct1))
                           |&gt; not strip ? (fn th =&gt; th RS' (ctxt', @{thm' Premise_I[where mode=MODE_GUARD]})))
                     | NONE =&gt; NONE)
             end
   else*) NONE
  end
*)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>extract_prems</span></span><span> </span><span class="entity"><span>thm</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>extract</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Thm.concl_of</span><span> </span><span class="entity"><span>th</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>XX</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>(</span></span><span>
              </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>XX</span></span><span>
                </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.All|const"><span>HOL.All</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                    </span><span class="entity"><span>extract</span></span><span> </span><span class="main"><span>(</span></span><span>Conv.fconv_rule</span><span> </span><span class="main"><span>(</span></span><span>Conv.rewr_conv</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.atomize_all|fact"><span>atomize_all</span></a><span class="main"><span>[</span></span><span class="operator"><span>symmetric</span></span><span class="main"><span>]</span></span><span class="antiquote"><span>}</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span>
                 </span><span class="main"><span>|</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.\&lt;r&gt;Guard|const"><span>𝗋Guard</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                    </span><span class="entity"><span>extract</span></span><span> </span><span class="main"><span>(</span></span><span>Conv.fconv_rule</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>HOLogic.Trueprop_conv</span></span><span> </span><span class="main"><span>(</span></span><span>Conv.rewr_conv</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.\&lt;r&gt;Guard_def|fact"><span>𝗋Guard_def</span></a><span class="antiquote"><span>}</span></span></span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span>
                 </span><span class="main"><span>|</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.conj|const"><span>HOL.conj</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                    </span><span>maps</span><span> </span><span class="entity"><span>extract</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>PLPR_Syntax.elim_ant_sequence_or_HOL_conj</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span>
                 </span><span class="main"><span>|</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Ant_Seq|const"><span>Ant_Seq</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                    </span><span>maps</span><span> </span><span class="entity"><span>extract</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>PLPR_Syntax.elim_ant_sequence_or_HOL_conj</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span>
                 </span><span class="main"><span>|</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise|const"><span>Premise</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span>Const</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>M</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                    </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>is_syntactic_premise_mode</span></span><span> </span><span class="entity"><span>M</span></span><span>
                    </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="main"><span>[</span></span><span>Conv.fconv_rule</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>HOLogic.Trueprop_conv</span></span><span> </span><span class="main"><span>(</span></span><span>Conv.rewr_conv</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise_def|fact"><span>Premise_def</span></a><span class="antiquote"><span>}</span></span></span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>]</span></span><span>
                    </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span>
                 </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span>
             </span><span class="main"><span>)</span></span><span>
           </span><span class="main"><span>|</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><span>Pure.all</span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                </span><span class="entity"><span>extract</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.forall_elim_var</span><span> </span><span class="main"><span>(</span></span><span>Thm.maxidx_of</span><span> </span><span class="entity"><span>th</span></span><span>+</span><span class="inner_numeral"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span>
           </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>extract</span></span><span> </span><span class="entity"><span>thm</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>


</span><span class="comment1"><span>(** Applications of the Premise Extraction **)</span></span><span>


</span><span class="comment1"><span>(* if not use_origin, drops the original premises and only remains the extracted premises. *)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>gen_simplify</span></span><span> </span><span class="entity"><span>simp</span></span><span> </span><span class="entity"><span>use_origin</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>extract</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>extract_prems</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>extract'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>use_origin</span></span><span>
                     </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span>::</span><span> </span><span class="entity"><span>extract</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span>
                     </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>extract</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>th</span></span><span class="main"><span>]</span></span><span> </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>L</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>L</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>sctxt</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Simplifier.set_mksimps</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                      </span><span>maps</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Simpdata.mksimps</span></span><span> </span><span class="entity"><span>Simpdata.mksimps_pairs</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span>
                    </span><span>o</span><span> </span><span class="entity"><span>extract'</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>simp</span></span><span> </span><span class="entity"><span>sctxt</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>asm_simplify</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>gen_simplify</span></span><span> </span><span class="entity"><span>Simplifier.asm_simplify</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>asm_lr_simplify</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>gen_simplify</span></span><span> </span><span class="entity"><span>Simplifier.asm_lr_simplify</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>full_simplify</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>gen_simplify</span></span><span> </span><span class="entity"><span>Simplifier.full_simplify</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>asm_simp_tac</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>gen_simplify</span></span><span> </span><span class="entity"><span>Simplifier.asm_simp_tac</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>asm_lr_simp_tac</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>gen_simplify</span></span><span> </span><span class="entity"><span>Simplifier.asm_lr_simp_tac</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>asm_rewrite</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>gen_simplify</span></span><span> </span><span class="entity"><span>Simplifier.asm_rewrite</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>asm_lr_rewrite</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>gen_simplify</span></span><span> </span><span class="entity"><span>Simplifier.asm_lr_rewrite</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>asm_full_rewrite</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>gen_simplify</span></span><span> </span><span class="entity"><span>Simplifier.asm_full_rewrite</span></span><span>

</span><span class="comment1"><span>(** Obligation Extraction **)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>contract_premise_imp</span></span><span> </span><span class="main"><span>=</span></span><span>
    </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>lemma</span></span><span> </span><span class="quoted"><span>‹</span><span class="main"><span>(</span></span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>Waste</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="free"><span>G</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>≡</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>Waste</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>P</span></span><span> </span><span class="main"><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.implies|const"><span>⟶</span></a></span><span> </span><span class="free"><span>G</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>›</span></span><span>
            </span><span class="quasi_keyword"><span>by</span></span><span> </span><span class="main"><span>(</span></span><a class="entity_ref" href="../../../../../../../HOL/HOL/ISABELLE_HOME/src/Provers/classical.ML.html#HOL.rule|method"><span class="operator"><span>rule</span></span></a><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>simp</span></span><span> </span><span class="quasi_keyword"><span>add</span></span><span class="main"><span>:</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise_def|fact"><span>Premise_def</span></a><span class="main"><span>)</span></span><span class="main"><span class="keyword3"><span>+</span></span></span><span class="main"><span>)</span></span><span class="antiquote"><span>}</span></span></span></span><span>

</span><span class="comment1"><span>(*the term must be beta-eta normalized*)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>obligation_collect</span></span><span> </span><span class="entity"><span>counter</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>conv</span></span><span> </span><span class="entity"><span>ctm</span></span><span> </span><span class="main"><span>=</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Thm.term_of</span><span> </span><span class="entity"><span>ctm</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                </span><span>Conv.rewr_conv</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.True_implies_equals|fact"><span>True_implies_equals</span></a><span class="main"><span>[</span></span><span class="operator"><span>symmetric</span></span><span class="main"><span>]</span></span><span class="antiquote"><span>}</span></span></span></span><span> </span><span class="entity"><span>ctm</span></span><span>
           </span><span class="main"><span>|</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><span>Pure.imp</span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>A</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span>
               </span><span class="main"><span>=&gt;</span></span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>is_syntactic_premise</span></span><span> </span><span class="entity"><span>A</span></span><span>
                  </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>counter</span></span><span> </span><span>:=</span><span> </span><span>!</span><span class="entity"><span>counter</span></span><span> </span><span>+</span><span> </span><span class="inner_numeral"><span>1</span></span><span class="main"><span>;</span></span><span>
                         </span><span class="main"><span>(</span></span><span>Conv.implies_conv</span><span>
                            </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Conv.atomize_conv</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>then_conv</span><span>
                             </span><span class="entity"><span>strip_premise_tag</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span>
                            </span><span class="entity"><span>conv</span></span><span> </span><span>then_conv</span><span>
                          </span><span>Conv.rewr_conv</span><span> </span><span class="entity"><span>contract_premise_imp</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctm</span></span><span class="main"><span>)</span></span><span>
                  </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="main"><span>(</span></span><span>Conv.arg_conv</span><span> </span><span class="entity"><span>conv</span></span><span> </span><span>then_conv</span><span>
                        </span><span>Conv.rewr_conv</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../../../Pure/Pure/Pure.html#Pure.conjunction_imp|fact"><span>conjunction_imp</span></a><span class="main"><span>[</span></span><span class="operator"><span>symmetric</span></span><span class="main"><span>]</span></span><span class="antiquote"><span>}</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctm</span></span><span class="main"><span>)</span></span><span>
           </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span>CTERM</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"unexpected proof obligation form"</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>ctm</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>conv</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="comment1"><span>(* REMOVE THIS WHEN NO BUG
fun obligation_collect ctxt filter ctm =
  Phi_Help.lambda_normalization_conv (fn ctm =&gt;
    case Thm.term_of ctm
      of Const(<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹Trueprop›, _) $ _ =&gt;
            Conv.rewr_conv @{thm True_implies_equals[symmetric]} ctm
       | Const(<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹Pure.imp›, _) $ Pr $ _
           =&gt; if filter Pr
              then (Conv.implies_conv
                      (Phi_Conv.atomize_conv ctxt then_conv
                       Raw_Simplifier.rewrite ctxt true @{thms' Premise_def[where mode=default]
                                                                Premise_def[where mode=MODE_GUARD]})
                      (obligation_collect ctxt filter) then_conv
                    Conv.rewr_conv @{thm' contract_premise_imp}) ctm
              else (Conv.arg_conv (obligation_collect ctxt filter) then_conv
                    Conv.rewr_conv @{thm' conjunction_imp[symmetric]}) ctm
       | _ =&gt; raise CTERM ("unexpected proof obligation form", [ctm])
  ) ctm
*)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>type</span></span></span><span> </span><span class="entity"><span>schm_by_ex</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>int</span><span>
</span><span class="keyword1"><span class="keyword"><span>type</span></span></span><span> </span><span class="entity"><span>contraction_mode</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>bool</span><span> * </span><span>bool</span><span> * </span><span class="entity"><span>schm_by_ex</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>chk_schm_by_ex</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="inner_numeral"><span>~1</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Config.get</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>existential_obligation</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>chk_schm_by_ex</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>i</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>chk_option</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>a</span></span><span class="main"><span>,</span></span><span class="entity"><span>b</span></span><span class="main"><span>,</span></span><span class="inner_numeral"><span>~1</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>a</span></span><span class="main"><span>,</span></span><span class="entity"><span>b</span></span><span class="main"><span>,</span></span><span>Config.get</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>existential_obligation</span></span><span class="main"><span>)</span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>chk_option</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="entity"><span>option</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>option</span></span><span>


</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>obligation_conv_all</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>ctm</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity"><span>Phi_Help.lambda_normalization_conv</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctm</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Thm.term_of</span><span> </span><span class="entity"><span>ctm</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><span>Pure.all</span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Conv.meta_all_conv</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>obligation_conv_all</span></span><span> </span><span>o</span><span> </span><span>snd</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>then_conv</span><span>
          </span><span>Conv.rewr_conv</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.contract_premise_all|fact"><span>contract_premise_all</span></a><span class="antiquote"><span>}</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctm</span></span><span>
     </span><span class="main"><span>|</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
          </span><span>Conv.all_conv</span><span> </span><span class="entity"><span>ctm</span></span><span>
     </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span>CTERM</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"internal bug 6733574a-42dc-4592-a08e-ddc223bb6b94"</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>ctm</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
  </span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctm</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>obligation_intro_Ex_conv'</span></span><span> </span><span class="entity"><span>conv_schematic</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>thm0</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>thm</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>Phi_Help.beta_eta_contract</span></span><span> </span><span class="entity"><span>thm0</span></span><span>
             </span><span>|&gt;</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>null</span><span> </span><span class="main"><span>(</span></span><span>Thm.tpairs_of</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="entity"><span>th</span></span><span>
                          </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Seq.chop</span><span> </span><span class="inner_numeral"><span>2</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.flexflex_rule</span><span> </span><span class="main"><span>(</span></span><span>SOME</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span>
                                 </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>[</span></span><span class="entity"><span>th'</span></span><span class="main"><span>]</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>th'</span></span><span>
                                  </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="comment1"><span>(*fails to solve flex-flex pairs*)</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>dest'</span></span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">Const</span><span class="hidden">&gt;</span></span></span><span>‹</span><span>Pure.imp</span><span>›</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span>Const</span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span>
                      </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise|const"><span>Premise</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>P</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>Q</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>P</span></span><span class="main"><span>,</span></span><span class="entity"><span>Q</span></span><span class="main"><span>)</span></span><span>
        </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>dest'</span></span><span> </span><span class="entity"><span>tm</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span>TERM</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"obligation_intro_Ex"</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>tm</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>dest</span></span><span> </span><span class="entity"><span>ctm</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>dest'</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.term_of</span><span> </span><span class="entity"><span>ctm</span></span><span class="main"><span>)</span></span><span>
      </span><span class="comment1"><span>(*fun dest_c ctm =
            (dest ctm; (Thm.dest_arg (Thm.dest_arg1 ctm), Thm.dest_arg ctm))*)</span></span><span>

      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>P</span></span><span class="main"><span>,</span></span><span class="entity"><span>Q</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>dest</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.cprop_of</span><span> </span><span class="entity"><span>thm</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>vars</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Term.add_vars</span><span> </span><span class="entity"><span>Q</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span>
              </span><span>|&gt;</span><span> </span><span>fold</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>A</span></span><span class="main"><span>,</span></span><span class="entity"><span>B</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Term.add_vars</span><span> </span><span class="entity"><span>A</span></span><span> </span><span>o</span><span> </span><span>Term.add_vars</span><span> </span><span class="entity"><span>B</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.tpairs_of</span><span> </span><span class="entity"><span>thm</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>collect_var</span></span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="main"><span>(</span></span><span>Var</span><span> </span><span class="entity"><span>v</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>member</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>op</span></span></span><span> </span><span class="main"><span>=</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>vars</span></span><span> </span><span class="entity"><span>v</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="entity"><span>ret</span></span><span>
                                    </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span>insert</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>op</span></span></span><span> </span><span class="main"><span>=</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>v</span></span><span> </span><span class="entity"><span>ret</span></span><span>
        </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>collect_var</span></span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>A</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>B</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>collect_var</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>collect_var</span></span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="entity"><span>A</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>B</span></span><span>
        </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>collect_var</span></span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="main"><span>(</span></span><span>Abs</span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>collect_var</span></span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="entity"><span>X</span></span><span>
        </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>collect_var</span></span><span> </span><span class="entity"><span>ret</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>ret</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>vars'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>collect_var</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span> </span><span class="entity"><span>P</span></span><span>
                </span><span>|&gt;</span><span> </span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>N</span></span><span class="main"><span>,</span></span><span class="entity"><span>T</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Thm.var</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>N</span></span><span class="main"><span>,</span></span><span> </span><span>Thm.ctyp_of</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>T</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>mode</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>conv_schematic</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="inner_numeral"><span>2</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>contract_Ex_rule</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>mode</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.contract_intro_sp_Ex|fact"><span>contract_intro_sp_Ex</span></a><span class="antiquote"><span>}</span></span></span></span><span>
                                     </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.contract_intro_Ex|fact"><span>contract_intro_Ex</span></a><span class="antiquote"><span>}</span></span></span></span><span>
   </span><span class="comment1"><span>(* val mv_Ex_All = if mode then Phi_Conv.move_sp_Ex_inside_All_recursive
                              else Phi_Conv.move_Ex_inside_All_recursive
      val mv_Ex_Disj = if mode then Phi_Conv.move_sp_Ex_downto_Disj_recursive
                               else Phi_Conv.move_Ex_downto_Disj_recursive *)</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>intro_Ex</span></span><span> </span><span class="entity"><span>v</span></span><span> </span><span class="entity"><span>thm</span></span><span> </span><span class="main"><span>=</span></span><span>
            </span><span>Conv.fconv_rule</span><span> </span><span class="main"><span>(</span></span><span>
                </span><span>Conv.rewr_conv</span><span> </span><span class="entity"><span>contract_Ex_rule</span></span><span> </span><span>then_conv</span><span> </span><span class="main"><span>(</span></span><span>
                </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>mode</span></span><span>
                </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="entity"><span>Phi_Conv.leading_antecedent_conv</span></span><span> </span><span class="main"><span>(</span></span><span>
                    </span><span class="entity"><span>PLPR_Syntax.premise_tag_conv</span></span><span> </span><span class="main"><span>(</span></span><span>K</span><span> </span><span>true</span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>
                      </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Conv.move_sp_Ex_inside</span></span><span> </span><span class="main"><span>(</span></span><span>K</span><span> </span><span class="main"><span>(</span></span><span>
                                    </span><span>Conv.fun_conv</span><span> </span><span class="main"><span>(</span></span><span>Conv.rewr_conv</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.special_Ex_def|fact"><span>special_Ex_def</span></a><span class="antiquote"><span>}</span></span></span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span>
                      </span><span class="comment1"><span>(*mv_Ex_All (fn _ =&gt; mv_Ex_Disj Conv.all_conv) ctxt*)</span></span><span> </span><span class="main"><span>)</span></span><span>
                  </span><span class="main"><span>)</span></span><span>
                </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span>Conv.all_conv</span><span class="main"><span>)</span></span><span>
            </span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.forall_intr</span><span> </span><span class="entity"><span>v</span></span><span> </span><span class="entity"><span>thm</span></span><span class="main"><span>)</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>fold</span><span> </span><span class="entity"><span>intro_Ex</span></span><span> </span><span class="entity"><span>vars'</span></span><span> </span><span class="entity"><span>thm</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>obligation_intro_Ex_conv</span></span><span> </span><span class="entity"><span>conv_schematic</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>thm</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity"><span>obligation_intro_Ex_conv'</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>chk_schm_by_ex</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>conv_schematic</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>thm</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>augment_conditions</span></span><span> </span><span class="entity"><span>conds</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>sequent</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>can</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>PLPR_Syntax.dest_premise_tag</span></span><span> </span><span>o</span><span> </span><span class="entity"><span>HOLogic.dest_Trueprop</span></span><span> </span><span>o</span><span> </span><span class="entity"><span>Phi_Help.leading_antecedent'</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>sequent</span></span><span>
              </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span>THM</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"must be leaded by a bare premise antecedent quantified by no \
                                      \HHF conditions nor universal variables"</span></span><span class="main"><span>,</span></span><span> </span><span class="inner_numeral"><span>1</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>[</span></span><span class="entity"><span>sequent</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>conds</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Conv.atomize</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>o</span><span> </span><span>Thm.forall_intr_vars</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>conds</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>sequent</span></span><span>
   </span><span>|&gt;</span><span> </span><span>fold</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>cond</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span>Thm.implies_elim</span><span>
          </span><span class="antiquoted"><span class="entity"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">instantiate</span><span class="hidden">&gt;</span></span></span><span>‹</span><span class="free"><span>cond</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span>Thm.dest_arg</span><span> </span><span class="main"><span>(</span></span><span>Thm.cconcl_of</span><span> </span><span class="entity"><span>cond</span></span><span class="main"><span>)</span></span><span>›</span></span><span> </span><span class="keyword2"><span class="keyword"><span>and</span></span></span><span>
                      </span><span class="free"><span>mode</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span>Thm.dest_arg1</span><span> </span><span class="main"><span>(</span></span><span>Thm.dest_arg</span><span> </span><span class="main"><span>(</span></span><span>Thm.dest_arg1</span><span> </span><span class="main"><span>(</span></span><span>Thm.cprop_of</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>›</span></span><span> </span><span class="keyword2"><span class="keyword"><span>and</span></span></span><span>
                      </span><span class="free"><span>P</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="quoted"><span>‹</span><span>Thm.dest_arg</span><span> </span><span class="main"><span>(</span></span><span>Thm.dest_arg</span><span> </span><span class="main"><span>(</span></span><span>Thm.dest_arg1</span><span> </span><span class="main"><span>(</span></span><span>Thm.cprop_of</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>›</span></span><span>
                        </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="keyword1"><span class="command"><span>lemma</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>‹</span><span class="free"><span>cond</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="main"><span>(</span></span><span class="free"><span>cond</span></span><span> </span><span class="main"><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.implies|const"><span>⟶</span></a></span><span> </span><span class="free"><span>P</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise|const"><span>Premise</span></a><span> </span><span class="free"><span>mode</span></span><span> </span><span class="free"><span>P</span></span><span>›</span></span></span><span>
                              </span><span class="keyword2"><span class="keyword"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>unfold</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise_def|fact"><span>Premise_def</span></a><span class="main"><span class="keyword3"><span>,</span></span></span><span> </span><a class="entity_ref" href="../../../../../../../HOL/HOL/ISABELLE_HOME/src/Provers/blast.ML.html#HOL.blast|method"><span class="operator"><span>blast</span></span></a><span class="main"><span>)</span></span><span>›</span></span></span><span>
          </span><span class="entity"><span>cond</span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>conds</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="comment1"><span>(*the leading antecedent must be beta-eta normalized*)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>collect_obligation_premises</span></span><span> </span><span class="entity"><span>option</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>thm</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword3"><span class="keyword"><span>open</span></span></span><span> </span><span>Conv</span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>collect_premises</span></span><span class="main"><span>,</span></span><span class="entity"><span>conv_all</span></span><span class="main"><span>,</span></span><span class="entity"><span>conv_schematic</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>chk_option</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>option</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>new_cond</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Unsynchronized.ref</span><span> </span><span class="inner_numeral"><span>0</span></span><span>
  </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>rule1</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>gconv_rule</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Conv.meta_alls_conv</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> 
                </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>collect_premises</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="entity"><span>obligation_collect</span></span><span> </span><span class="entity"><span>new_cond</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
                                     </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span>Conv.all_conv</span><span class="main"><span>)</span></span><span> </span><span>then_conv</span><span>
                </span><span>rewr_conv</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><span>Pure.prop_def</span><span class="main"><span>[</span></span><span class="operator"><span>symmetric</span></span><span class="main"><span>]</span></span><span class="antiquote"><span>}</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
              </span><span class="main"><span>)</span></span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="entity"><span>thm</span></span><span>

  </span><span class="comment1"><span>(*val rule2 = if collect_premises
              then case Local_Premises_of_Obligation.get ctxt
                of [] =&gt; rule1
                 | L =&gt; let val fact = map (Conv.fconv_rule (Object_Logic.atomize ctxt)) L
                                    |&gt; foldl1 (uncurry (HOLogic.conj_intr ctxt))
                         in fact RS (@{thm' contract_add_additional_prems} RS rule1)
                        end
              else rule1*)</span></span><span>

  </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>drop_wastes</span></span><span> </span><span class="entity"><span>thm</span></span><span> </span><span class="main"><span>=</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Thm.major_prem_of</span><span> </span><span class="entity"><span>thm</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><span>Pure.prop</span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>(</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><span>Pure.imp</span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span>
                      </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>drop_wastes</span></span><span> </span><span class="main"><span>(</span></span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.contract_drop_waste|fact"><span>contract_drop_waste</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>thm</span></span><span class="main"><span>)</span></span><span>
                  </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>lemma'</span></span><span> </span><span class="quoted"><span>‹ </span><span class="keyword1"><span>PROP</span></span><span> </span><span class="free"><span>P</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="keyword1"><span>PROP</span></span><span> </span><span>Pure.prop</span><span> </span><span class="free"><span>P</span></span><span> ›</span></span><span> </span><span class="quasi_keyword"><span>by</span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>unfold</span></span><span> </span><span>Pure.prop_def</span><span class="main"><span>)</span></span><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>thm</span></span><span class="main"><span>)</span></span><span>
       </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>error</span><span> </span><span class="inner_quoted"><span>"BUG nhtCAsmjS+Oj4YsI8qtXQw"</span></span><span>

   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>drop_wastes</span></span><span> </span><span class="entity"><span>rule1</span></span><span>
   </span><span>|&gt;</span><span> </span><span class="entity"><span>conv_all</span></span><span> </span><span>?</span><span> </span><span>gconv_rule</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>obligation_conv_all</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="inner_numeral"><span>1</span></span><span>
   </span><span>|&gt;</span><span> </span><span class="entity"><span>conv_schematic</span></span><span> </span><span>&gt;</span><span> </span><span class="inner_numeral"><span>0</span></span><span> </span><span>?</span><span> </span><span class="entity"><span>obligation_intro_Ex_conv'</span></span><span> </span><span class="entity"><span>conv_schematic</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
   </span><span>|&gt;</span><span> </span><span>pair</span><span> </span><span class="main"><span>(</span></span><span>!</span><span class="entity"><span>new_cond</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="comment1"><span>(*Config.get ctxt existential_obligation*)</span></span><span>

</span><span class="comment1"><span>(*the leading antecedent must be beta-eta normalized*)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>contract_obligations</span></span><span> </span><span class="entity"><span>mode</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>thm</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>thm</span></span><span>
    </span><span>|&gt;</span><span> </span><span class="entity"><span>collect_obligation_premises</span></span><span> </span><span class="entity"><span>mode</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>|&gt;</span><span> </span><span>snd</span><span>
    </span><span>|&gt;</span><span> </span><span>Conv.fconv_rule</span><span> </span><span class="main"><span>(</span></span><span>Conv.rewr_conv</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.contract_obligations|fact"><span>contract_obligations</span></a><span class="antiquote"><span>}</span></span></span></span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>find_obligations_tag</span></span><span> </span><span class="entity"><span>thm</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>tl</span><span> </span><span class="main"><span>(</span></span><span>Thm.prems_of</span><span> </span><span class="entity"><span>thm</span></span><span class="main"><span>)</span></span><span>
      </span><span>|&gt;</span><span> </span><span>find_index</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>tm</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
            </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span class="entity"><span>tm</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise|const"><span>Premise</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.MODE_COLLECT|const"><span>MODE_COLLECT</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>true</span><span>
                     </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>false</span><span class="main"><span>)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>has_obligations_tag</span></span><span> </span><span class="entity"><span>thm</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>find_obligations_tag</span></span><span> </span><span class="entity"><span>thm</span></span><span> </span><span>&lt;&gt;</span><span> </span><span class="inner_numeral"><span>~1</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>defer_obligation</span></span><span> </span><span class="entity"><span>cfg</span></span><span> </span><span class="entity"><span>contract</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>oblg_template</span></span><span> </span><span>false</span><span> </span><span class="entity"><span>cfg</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>thm</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>idx</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>find_obligations_tag</span></span><span> </span><span class="entity"><span>thm</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>idx</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="inner_numeral"><span>~1</span></span><span>
     </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span>error</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"Fail to defer a proof obligation: an 𝗈𝖻𝗅𝗂𝗀𝖺𝗍𝗂𝗈𝗇 antecedent is not found."</span></span><span class="main"><span>)</span></span><span>
     </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span>Thm.permute_prems</span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="entity"><span>idx</span></span><span> </span><span class="entity"><span>thm</span></span><span>
      </span><span>|&gt;</span><span> </span><span class="entity"><span>contract</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
      </span><span>|&gt;</span><span> </span><span>Thm.permute_prems</span><span> </span><span class="inner_numeral"><span>0</span></span><span> </span><span class="main"><span>(</span></span><span>~</span><span class="entity"><span>idx</span></span><span class="main"><span>)</span></span><span>
      </span><span>|&gt;</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>X</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>X</span></span><span class="main"><span>,</span></span><span> </span><span>Seq.empty</span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>defer_obligation_tac</span></span><span> </span><span class="entity"><span>cfg</span></span><span> </span><span class="entity"><span>contr_mode</span></span><span> </span><span class="main"><span>=</span></span><span>
      </span><span class="entity"><span>defer_obligation</span></span><span> </span><span class="entity"><span>cfg</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>contract_obligations</span></span><span> </span><span class="entity"><span>contr_mode</span></span><span class="main"><span>)</span></span><span>

</span><span class="comment1"><span>(*** Premise tac ***)</span></span><span>

</span><span class="comment1"><span>(*fun intro_all_leading_ex i thm =
  if i &gt; Thm.nprems_of thm
  then thm
  else case Logic.concl_of_goal (Thm.prop_of thm) i
         of _ (*Trueprop*) $ (Const(<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹HOL.conj›, _) $ _ $ _) =&gt;
              intro_all_leading_ex i (@{thm' conjI} RSN (i, thm))
          | _ (*Trueprop*) $ (Const(<span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span>‹HOL.Ex›, _) $ _ ) =&gt;
              intro_all_leading_ex i (@{thm' exI} RSN (i, thm))
          | _ =&gt; intro_all_leading_ex (i+1) thm*)</span></span><span>

</span><span class="comment1"><span>(*Attack antecedents @{term "Premise mode P"} using the classical auto tactic.
It is the default tactic in the system intended to solve simple proof obligations.*)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>auto_obligation_solver</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>oblg_template</span></span><span> </span><span>true</span><span> </span><span class="main"><span>{</span></span><span>can_inst</span><span class="main"><span>=</span></span><span>true</span><span class="main"><span>,</span></span><span> fix_level</span><span class="main"><span>=</span></span><span class="inner_numeral"><span>0</span></span><span class="main"><span>}</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>th'1</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>collect_obligation_premises</span></span><span> </span><span class="main"><span>(</span></span><span>true</span><span class="main"><span>,</span></span><span> </span><span>true</span><span class="main"><span>,</span></span><span> </span><span>Config.get</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>existential_obligation</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>th</span></span><span>
          </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>th'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thm'</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise_I|fact"><span>Premise_I</span></a><span class="antiquote"><span>}</span></span></span></span><span> </span><span>RS</span><span> </span><span class="entity"><span>th'1</span></span><span>
       </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>th'</span></span><span>
       </span><span>|&gt;</span><span> </span><span class="entity"><span>head_only</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>apply_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>pre</span></span><span class="main"><span>,</span></span><span class="entity"><span>aux</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
          </span><span class="entity"><span>pre</span></span><span> </span><span>THEN</span><span> </span><span>HEADGOAL</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Method.insert_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>aux</span></span><span class="main"><span>)</span></span><span>
              </span><span>THEN</span><span> </span><span class="entity"><span>Clasimp.auto_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>Agressive_Solver</span></span><span class="main"><span>)</span></span><span>
       </span><span>|&gt;</span><span> </span><span>Seq.pull</span><span>
      </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>auto_obligation_solver'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>context_tactic_to_state_transition</span></span><span> </span><span class="entity"><span>auto_obligation_solver</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>auto_obligation_solver1</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>sequent</span></span><span> </span><span class="main"><span>=</span></span><span>  </span><span class="main"><span>(</span></span><span>
        </span><span class="entity"><span>Phi_Reasoner.info_pretty</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="inner_numeral"><span>2</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Pretty.chunks</span><span> </span><span class="main"><span>[</span></span><span>
            </span><span>Pretty.str</span><span> </span><span class="inner_quoted"><span>"Solving the following goal using ‹auto› method..."</span></span><span class="main"><span>,</span></span><span>
            </span><span>Syntax.pretty_term</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.major_prem_of</span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>
            </span><span>Pretty.block</span><span> </span><span class="main"><span>(</span></span><span>Pretty.here</span><span> </span><span class="antiquoted"><span class="operator"><span class="entity"><span>⌂</span></span></span></span><span class="main"><span>)</span></span><span>
        </span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
        </span><span class="entity"><span>auto_obligation_solver'</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
          </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span class="entity"><span>Automation_Fail</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                  </span><span>Pretty.para</span><span> </span><span class="inner_quoted"><span>"Fail to solve the proof obligation automatically"</span></span><span> </span><span>::</span><span>
                  </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Thm.prems_of</span><span> </span><span class="entity"><span>sequent</span></span><span>
                     </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>x</span></span><span>::</span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span>
                          </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>[</span></span><span>Syntax.pretty_term</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>x</span></span><span class="main"><span>]</span></span><span>
                      </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>[</span></span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
          </span><span class="comment1"><span>(*error (Pretty.string_of (Pretty.chunks [
              Pretty.str "Fail to solve the proof obligation automatically:",
              Syntax.pretty_term ctxt Goal
            ])) *)</span></span><span>
        </span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>sequent</span></span><span>
     </span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>norm_tac</span></span><span> </span><span class="entity"><span>tac</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.pull</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>tac</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>timed_seq</span></span><span> </span><span class="entity"><span>time</span></span><span> </span><span class="entity"><span>s</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> 
    </span><span>Timeout.apply</span><span> </span><span class="entity"><span>time</span></span><span> </span><span>Seq.pull</span><span> </span><span class="entity"><span>s</span></span><span>
      </span><span class="keyword3"><span class="keyword"><span>handle</span></span></span><span> </span><span>Timeout.TIMEOUT</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>NONE</span><span> </span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>timed_tac</span></span><span> </span><span class="entity"><span>time</span></span><span> </span><span class="entity"><span>tac</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>timed_seq</span></span><span> </span><span class="entity"><span>time</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>tac</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>timed1_tac</span></span><span> </span><span class="entity"><span>time</span></span><span> </span><span class="entity"><span>t'</span></span><span> </span><span class="entity"><span>tac</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>s</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>tac</span></span><span> </span><span class="entity"><span>th</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
      </span><span>Timeout.apply</span><span> </span><span class="entity"><span>time</span></span><span> </span><span>Seq.pull</span><span> </span><span class="entity"><span>s</span></span><span>
      </span><span class="keyword3"><span class="keyword"><span>handle</span></span></span><span> </span><span>Timeout.TIMEOUT</span><span> </span><span class="entity"><span>t''</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
        </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>t''</span></span><span> </span><span>&gt;</span><span> </span><span class="entity"><span>t'</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span>Timeout.TIMEOUT</span><span> </span><span class="entity"><span>t''</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span>NONE</span><span> </span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>quick_cut</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Logic.strip_assums_concl</span><span> </span><span class="main"><span>(</span></span><span>Logic.nth_prem</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>i</span></span><span class="main"><span>,</span></span><span> </span><span>Thm.prop_of</span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.False|const"><span>False</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.empty</span><span>
     </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.single</span><span> </span><span class="entity"><span>th</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>slow_step_tac'</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity"><span>Classical.appWrappers</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
    </span><span class="main"><span>(</span></span><span class="entity"><span>Classical.instp_step_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>APPEND'</span><span> </span><span class="entity"><span>Classical.unsafe_step_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>nodup_depth_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>m</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>st</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span>SELECT_GOAL</span><span>
    </span><span class="main"><span>(</span></span><span class="entity"><span>Classical.safe_steps_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span>THEN_ELSE</span><span>
      </span><span class="main"><span>(</span></span><span>DEPTH_SOLVE</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>nodup_depth_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>m</span></span><span> </span><span class="inner_numeral"><span>1</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>
        </span><span class="entity"><span>Classical.inst0_step_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span>APPEND</span><span> </span><span>COND</span><span> </span><span class="main"><span>(</span></span><span>K</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>m</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="inner_numeral"><span>0</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>no_tac</span><span>
          </span><span class="main"><span>(</span></span><span class="entity"><span>slow_step_tac'</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span>THEN</span><span> </span><span>DEPTH_SOLVE</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>nodup_depth_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>m</span></span><span> </span><span>-</span><span> </span><span class="inner_numeral"><span>1</span></span><span class="main"><span>)</span></span><span> </span><span class="inner_numeral"><span>1</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>st</span></span><span class="main"><span>;</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>auto_search_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Context_Position.set_visible</span><span> </span><span>false</span><span> </span><span class="entity"><span>ctxt</span></span><span>
    </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>main_tac</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>=</span></span><span>
        </span><span>CHANGED</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>nodup_depth_tac</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>addss</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="inner_numeral"><span>10</span></span><span> </span><span class="entity"><span>i</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
    </span><span class="entity"><span>norm_tac</span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span>
      </span><span>TRY</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Classical.safe_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span>THEN</span><span>
      </span><span>REPEAT_DETERM</span><span> </span><span class="main"><span>(</span></span><span>FIRSTGOAL</span><span> </span><span class="entity"><span>main_tac</span></span><span class="main"><span>)</span></span><span> </span><span>THEN</span><span>
      </span><span>TRY</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Classical.safe_tac</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>addSss</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span>THEN</span><span>
      </span><span>prune_params_tac</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span>
      </span><span>#&gt;</span><span> </span><span>Seq.take</span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>;</span></span><span>


</span><span class="comment1"><span>(*
fun auto_search1_tac ctxt t th =
  norm_tac (auto_search_tac ctxt t) th
    |&gt; Seq.take 1 *)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>dest_all</span></span><span> </span><span class="entity"><span>ct</span></span><span> </span><span class="entity"><span>used</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Thm.term_of</span><span> </span><span class="entity"><span>ct</span></span><span> </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span>
    </span><span>Const</span><span> </span><span class="main"><span>(</span></span><span class="inner_quoted"><span>"Pure.all"</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span>Abs</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>x</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>x'</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>used'</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Name.variant</span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="entity"><span>used</span></span><span class="main"><span>;</span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>v</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>ct'</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.dest_abs_fresh</span><span> </span><span class="entity"><span>x'</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.dest_arg</span><span> </span><span class="entity"><span>ct</span></span><span class="main"><span>)</span></span><span class="main"><span>;</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="main"><span>(</span></span><span class="entity"><span>x</span></span><span class="main"><span>,</span></span><span> </span><span>Thm.ctyp_of_cterm</span><span> </span><span class="entity"><span>v</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ct'</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>used'</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
  </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>NONE</span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>negation</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="antiquoted"><span class="entity"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">cterm</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.Not|const"><span>Not</span></a><span>›</span></span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>prove_or_rebute</span></span><span> </span><span class="entity"><span>can_inst</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>ctxt0</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>search</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>auto_search_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span>
   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>timed_tac</span></span><span> </span><span class="main"><span>(</span></span><span>Time.fromMilliseconds</span><span> </span><span class="inner_numeral"><span>30</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>search</span></span><span> </span><span>ORELSE</span><span>
  </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>exception</span></span></span><span> </span><span class="entity"><span>Unsupported</span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>goals</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.cprems_of</span><span> </span><span class="entity"><span>th</span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>fail</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="main"><span>(</span></span><span>
              </span><span>List.app</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>goal</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                </span><span class="entity"><span>Phi_Reasoner.warn_pretty</span></span><span> </span><span class="main"><span>(</span></span><span>Context.Proof</span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword3"><span class="keyword"><span>open</span></span></span><span> </span><span>Pretty</span><span> </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
                  </span><span>chunks</span><span> </span><span class="main"><span>(</span></span><span>
                    </span><span class="main"><span>[</span></span><span>block</span><span> </span><span class="main"><span>(</span></span><span>text</span><span> </span><span class="inner_quoted"><span>"Fail to prove or falisfy the following guard condition"</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>
                    </span><span class="entity"><span>Goal_Display.pretty_a_goal</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.term_of</span><span> </span><span class="entity"><span>goal</span></span><span class="main"><span>)</span></span><span class="main"><span>,</span></span><span>
                    </span><span>block</span><span> </span><span class="main"><span>(</span></span><span>text</span><span> </span><span class="inner_quoted"><span>"We assume the conditions do not hold and this assumption can cause reasoning failure."</span></span><span class="main"><span>)</span></span><span class="main"><span>]</span></span><span>
                    </span><span class="main"><span>)</span></span><span>
                </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>goals</span></span><span>
              </span><span class="main"><span>;</span></span><span> </span><span>NONE</span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
     </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>exception</span></span></span><span> </span><span class="entity"><span>Falsified</span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>conv_goal</span></span><span> </span><span class="entity"><span>used</span></span><span> </span><span class="entity"><span>ctm</span></span><span> </span><span class="main"><span>=</span></span><span>
          </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Thm.term_of</span><span> </span><span class="entity"><span>ctm</span></span><span>  
            </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><span>Pure.imp</span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>f</span></span><span class="main"><span>,</span></span><span class="entity"><span>a</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.dest_comb</span><span> </span><span class="entity"><span>ctm</span></span><span>
                   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>Thm.apply</span><span> </span><span class="entity"><span>f</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>conv_goal</span></span><span> </span><span class="entity"><span>used</span></span><span> </span><span class="entity"><span>a</span></span><span class="main"><span>)</span></span><span>
                  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
             </span><span class="main"><span>|</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><span>Pure.all</span><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span>Abs</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>x</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>q</span></span><span class="main"><span>,</span></span><span class="entity"><span>b</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.dest_comb</span><span> </span><span class="entity"><span>ctm</span></span><span>
                      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>x'</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>used'</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Name.variant</span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="entity"><span>used</span></span><span class="main"><span>;</span></span><span>
                      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>v</span></span><span class="main"><span>,</span></span><span> </span><span class="entity"><span>b'</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.dest_abs_fresh</span><span> </span><span class="entity"><span>x'</span></span><span> </span><span class="entity"><span>b</span></span><span>
                   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>Thm.apply</span><span> </span><span class="entity"><span>q</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.lambda</span><span> </span><span class="entity"><span>v</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>conv_goal</span></span><span> </span><span class="entity"><span>used'</span></span><span> </span><span class="entity"><span>b'</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
                  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
             </span><span class="main"><span>|</span></span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>c</span></span><span class="main"><span>,</span></span><span class="entity"><span>b</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Thm.dest_comb</span><span> </span><span class="entity"><span>ctm</span></span><span>
                   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>Thm.apply</span><span> </span><span class="entity"><span>c</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.apply</span><span> </span><span class="entity"><span>negation</span></span><span> </span><span class="entity"><span>b</span></span><span class="main"><span>)</span></span><span>
                  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
             </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span class="entity"><span>Unsupported</span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>goals</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>map</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>goal</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
                      </span><span>Goal.init</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>conv_goal</span></span><span> </span><span class="main"><span>(</span></span><span>Term.declare_term_frees</span><span> </span><span class="main"><span>(</span></span><span>Thm.term_of</span><span> </span><span class="entity"><span>goal</span></span><span class="main"><span>)</span></span><span> </span><span>Name.context</span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>goal</span></span><span class="main"><span>)</span></span><span>
                    </span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>goals</span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>goals</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>can_inst</span></span><span>
                    </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span>Variable.import</span><span> </span><span>false</span><span> </span><span class="entity"><span>goals</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>|&gt;</span><span> </span><span class="main"><span>#</span></span><span class="inner_numeral"><span>1</span></span><span> </span><span>|&gt;</span><span> </span><span class="main"><span>#</span></span><span class="inner_numeral"><span>2</span></span><span>
                    </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span>Variable.export</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>ctxt0</span></span><span> </span><span class="entity"><span>goals</span></span><span>
        </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>falsify</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
            </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span>exists</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>goal</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
              </span><span class="keyword2"><span class="keyword"><span>case</span></span></span><span> </span><span>Seq.pull</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>search</span></span><span> </span><span class="entity"><span>goal</span></span><span class="main"><span>)</span></span><span>
                </span><span class="keyword2"><span class="keyword"><span>of</span></span></span><span> </span><span>SOME</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ret</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Thm.no_prems</span><span> </span><span class="entity"><span>ret</span></span><span>
                 </span><span class="main"><span>|</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>false</span><span> </span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>goals</span></span><span>
            </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="keyword3"><span class="keyword"><span>raise</span></span></span><span> </span><span class="entity"><span>Falsified</span></span><span>
            </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span>NONE</span><span>
          </span><span class="main"><span>)</span></span><span>
     </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span>Seq.make</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>Seq.pull</span><span> </span><span class="main"><span>(</span></span><span>
            </span><span class="entity"><span>timed_seq</span></span><span> </span><span class="main"><span>(</span></span><span>Time.fromMilliseconds</span><span> </span><span class="inner_numeral"><span>30</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>falsify</span></span><span> </span><span class="entity"><span>ORELSE0</span></span><span>
            </span><span class="entity"><span>timed_seq</span></span><span> </span><span class="main"><span>(</span></span><span>Time.fromMilliseconds</span><span> </span><span class="inner_numeral"><span>250</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>search</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ORELSE0</span></span><span>
            </span><span class="entity"><span>timed_seq</span></span><span> </span><span class="main"><span>(</span></span><span>Time.fromMilliseconds</span><span> </span><span class="inner_numeral"><span>100</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>falsify</span></span><span> </span><span class="entity"><span>ORELSE0</span></span><span>
            </span><span class="entity"><span>fail</span></span><span> </span><span class="main"><span>)</span></span><span>
          </span><span class="keyword3"><span class="keyword"><span>handle</span></span></span><span> </span><span class="entity"><span>Falsified</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span>NONE</span><span class="main"><span>)</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span> </span><span class="keyword3"><span class="keyword"><span>handle</span></span></span><span> </span><span class="entity"><span>Unsupported</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
      </span><span class="entity"><span>timed_tac</span></span><span> </span><span class="main"><span>(</span></span><span>Time.fromMilliseconds</span><span> </span><span class="inner_numeral"><span>300</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>auto_search_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="entity"><span>ORELSE0</span></span><span>
      </span><span class="entity"><span>fail</span></span><span>
    </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

  


</span><span class="comment1"><span>(*It is another tactic using 'clarsimp' method. It is weaker than 'auto' but much safer
and will usually terminate (if no loop is encountered in the simplification)*)</span></span><span>
</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>guard_condition_solver</span></span><span> </span><span class="main"><span>{</span></span><span class="entity"><span>can_inst</span></span><span class="main"><span>}</span></span><span> </span><span class="entity"><span>ctxt0</span></span><span> </span><span class="entity"><span>th0</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>is_guard_mode</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.MODE_GUARD|const"><span>MODE_GUARD</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>true</span><span>
        </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_guard_mode</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.NO_INST|const"><span>NO_INST</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>true</span><span>
        </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_guard_mode</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>false</span><span>
      </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>is_false</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise|const"><span>Premise</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>mode</span></span><span> </span><span>$</span><span> </span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.False|const"><span>False</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
            </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>is_guard_mode</span></span><span> </span><span class="entity"><span>mode</span></span><span>
        </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_false</span></span><span> </span><span class="main"><span>(</span></span><span>Const</span><span class="main"><span>(</span></span><span class="antiquoted"><span class="operator"><span><span class="hidden">\&lt;^</span><span class="control">const_name</span><span class="hidden">&gt;</span></span></span><span>‹</span><a class="entity_ref" href="../../../../../../../HOL/HOL/HOL.html#HOL.Trueprop|const"><span>Trueprop</span></a><span>›</span></span><span class="main"><span>,</span></span><span> </span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span>$</span><span> </span><span class="entity"><span>X</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>is_false</span></span><span> </span><span class="entity"><span>X</span></span><span>
        </span><span class="main"><span>|</span></span><span> </span><span class="entity"><span>is_false</span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>false</span><span>
      </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>is_F</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>is_false</span></span><span> </span><span class="main"><span>(</span></span><span>Thm.major_prem_of</span><span> </span><span class="entity"><span>th0</span></span><span class="main"><span>)</span></span><span>

   </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> </span><span class="entity"><span>oblg_template</span></span><span> </span><span>true</span><span> </span><span class="main"><span>{</span></span><span>can_inst </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>can_inst</span></span><span class="main"><span>,</span></span><span> fix_level</span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>can_inst</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="inner_numeral"><span>2</span></span><span> </span><span class="main"><span>}</span></span><span>
  </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="comment1"><span>(*val (new_conds, th'1) = collect_obligation_premises (true, true, Config.get ctxt existential_obligation) ctxt th
          val th' = @{thm' Premise_I} RS th'1*)</span></span><span>
          </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>th'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>th</span></span><span>
          </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>auto_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=</span></span><span>
                </span><span>ALLGOALS</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Simplifier.asm_full_simp_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>THEN_ALL_NEW</span><span> </span><span class="entity"><span>quick_cut</span></span><span class="main"><span>)</span></span><span> </span><span>THEN</span><span>
                </span><span class="main"><span>(</span></span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>is_F</span></span><span>
                 </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="entity"><span>timed_tac</span></span><span> </span><span class="main"><span>(</span></span><span>Time.fromMilliseconds</span><span> </span><span class="inner_numeral"><span>250</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>auto_search_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span>
                 </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="entity"><span>prove_or_rebute</span></span><span> </span><span class="entity"><span>can_inst</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>ctxt0</span></span><span class="main"><span>)</span></span><span>
                </span><span class="comment1"><span>(* (timed_tac (Time.fromMilliseconds 300) (auto_search_tac ctxt)) *)</span></span><span>
        </span><span class="comment1"><span>(*fun clarsimp_tac ctxt =
                Simplifier.asm_full_simp_tac (Guess_Instantiate.add_guess_inst_solver ctxt) THEN_ALL_NEW
             (*For some reason I don't know, some goals rely on unsafe tactics even when no variables occur 
               (if can_inst then Simplifier.asm_full_simp_tac ctxt
                            else Simplifier.safe_asm_full_simp_tac ctxt) THEN_ALL_NEW *)
                (fn i =&gt; fn th =&gt; timed_tac (Time.fromMilliseconds 300) (Classical.fast_tac (addSss ctxt) i) th)
          fun clarsimp'_tac ctxt =
                Simplifier.asm_full_simp_tac ctxt THEN_ALL_NEW
                (fn i =&gt; fn th =&gt; timed_tac (Time.fromMilliseconds 300) (Classical.fast_tac (addss ctxt) i) th)
          fun force_tac ctxt =
                Classical.clarify_tac ctxt THEN_ALL_NEW
                Simplifier.asm_full_simp_tac ctxt THEN_ALL_NEW
                (fn i =&gt; fn th =&gt; timed_tac (Time.fromMilliseconds 300) (Classical.first_best_tac (addss ctxt) i) th) *)</span></span><span>
       </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
        </span><span class="entity"><span>apply_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>pre</span></span><span class="main"><span>,</span></span><span class="entity"><span>aux</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>thtt</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>thtt</span></span><span> </span><span>|&gt;</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>quick_cut</span></span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span>THEN</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>head_only</span></span><span> </span><span class="main"><span>(</span></span><span>
             </span><span class="entity"><span>pre</span></span><span> </span><span class="comment1"><span>(*THEN REPEAT_DETERM_N new_conds (HEADGOAL (resolve_tac ctxt @{thms' impI}))*)</span></span><span>
                 </span><span>THEN</span><span> </span><span>HEADGOAL</span><span> </span><span class="main"><span>(</span></span><span>
                              </span><span class="entity"><span>case_split_by_annotations_leading_subgoal</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> 
                 </span><span>THEN_ALL_NEW</span><span> </span><span class="entity"><span>Method.insert_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>aux</span></span><span>
                 </span><span class="main"><span>)</span></span><span> </span><span>THEN</span><span> </span><span class="entity"><span>auto_tac</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Guess_Instantiate.add_guess_inst_solver</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span>addsimps</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thms'</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise_def|fact"><span>Premise_def</span></a><span class="antiquote"><span>}</span></span></span></span><span class="main"><span>)</span></span><span>
               </span><span class="comment1"><span>(* THEN_ALL_NEW (fn s =&gt; fn x =&gt; clarsimp_tac (ctxt addsimps @{thms' Premise_def}) s x) ) *)</span></span><span>
               </span><span class="comment1"><span>(*THEN_ALL_NEW (fn s =&gt; fn x =&gt; Clasimp.fast_force_tac
                      (Guess_Instantiate.add_guess_inst_solver ctxt addsimps @{thms' Premise_def}) s x)*)</span></span><span> </span><span class="main"><span>)</span></span><span>
               </span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>
              </span><span>|&gt;</span><span> </span><span>Seq.take</span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>Safe_Solver</span></span><span> </span><span class="entity"><span>th'</span></span><span>
       </span><span>|&gt;</span><span> </span><span>Seq.take</span><span> </span><span class="inner_numeral"><span>1</span></span><span>
       </span><span>|&gt;</span><span> </span><span>Seq.pull</span><span>
      </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt0</span></span><span> </span><span class="entity"><span>th0</span></span><span>
  </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>

</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>guard_condition_solver'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>context_tactic_to_state_transition</span></span><span> </span><span>o</span><span> </span><span class="entity"><span>guard_condition_solver</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>guard_condition_solver1</span></span><span> </span><span class="entity"><span>can_inst</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>sequent</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity"><span>guard_condition_solver'</span></span><span> </span><span class="entity"><span>can_inst</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
    </span><span>error</span><span> </span><span class="main"><span>(</span></span><span>Pretty.string_of</span><span> </span><span class="main"><span>(</span></span><span>Pretty.chunks</span><span> </span><span class="main"><span>[</span></span><span>
        </span><span>Pretty.str</span><span> </span><span class="inner_quoted"><span>"Fail to solve the proof obligation automatically:"</span></span><span class="main"><span>,</span></span><span>
        </span><span>Syntax.pretty_term</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Help.leading_antecedent'</span></span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span>
  </span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>sequent</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>safe_obligation_solver</span></span><span> </span><span class="main"><span>{</span></span><span class="entity"><span>can_inst</span></span><span class="main"><span>}</span></span><span> </span><span class="entity"><span>ctxt0</span></span><span> </span><span class="main"><span>=</span></span><span>
        </span><span class="entity"><span>oblg_template</span></span><span> </span><span>true</span><span> </span><span class="main"><span>{</span></span><span>can_inst </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>can_inst</span></span><span class="main"><span>,</span></span><span> fix_level</span><span class="main"><span>=</span></span><span> </span><span class="keyword2"><span class="keyword"><span>if</span></span></span><span> </span><span class="entity"><span>can_inst</span></span><span> </span><span class="keyword2"><span class="keyword"><span>then</span></span></span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="keyword2"><span class="keyword"><span>else</span></span></span><span> </span><span class="inner_numeral"><span>2</span></span><span> </span><span class="main"><span>}</span></span><span>
  </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
      </span><span class="keyword2"><span class="keyword"><span>let</span></span></span><span> </span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>th'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>th</span></span><span>
          </span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>clarsimp_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>=</span></span><span>
                </span><span class="entity"><span>Simplifier.asm_full_simp_tac</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Guess_Instantiate.add_guess_inst_solver</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span>THEN_ALL_NEW</span><span>
                </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>th</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>Classical.clarify_tac</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>addSss</span></span><span> </span><span class="entity"><span>ctxt</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>i</span></span><span> </span><span class="entity"><span>th</span></span><span class="main"><span>)</span></span><span>
       </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span>
        </span><span class="entity"><span>apply_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span class="main"><span>,</span></span><span class="entity"><span>pre</span></span><span class="main"><span>,</span></span><span class="entity"><span>aux</span></span><span class="main"><span>,</span></span><span class="main"><span>_</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>thtt</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>thtt</span></span><span> </span><span>|&gt;</span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>quick_cut</span></span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span>THEN</span><span> </span><span class="main"><span>(</span></span><span>
             </span><span class="entity"><span>pre</span></span><span> </span><span class="comment1"><span>(*THEN REPEAT_DETERM_N new_conds (HEADGOAL (resolve_tac ctxt @{thms' impI}))*)</span></span><span>
                 </span><span>THEN</span><span> </span><span>HEADGOAL</span><span> </span><span class="main"><span>(</span></span><span>
                              </span><span class="entity"><span>case_split_by_annotations_leading_subgoal</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> 
                 </span><span>THEN_ALL_NEW</span><span> </span><span class="entity"><span>Method.insert_tac</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>aux</span></span><span>
                 </span><span>THEN_ALL_NEW</span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>s</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="entity"><span>x</span></span><span> </span><span class="main"><span>=&gt;</span></span><span> </span><span class="entity"><span>clarsimp_tac</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>ctxt</span></span><span> </span><span>addsimps</span><span> </span><span class="antiquoted"><span class="entity"><span class="antiquote"><span>@{</span></span><span class="operator"><span>thms'</span></span><span> </span><a class="entity_ref" href="../../../../../Phi_Logic_Programming_Reasoner.PLPR.html#PLPR.Premise_def|fact"><span>Premise_def</span></a><span class="antiquote"><span>}</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>s</span></span><span> </span><span class="entity"><span>x</span></span><span class="main"><span>)</span></span><span> </span><span class="main"><span>)</span></span><span>
               </span><span class="comment1"><span>(*THEN_ALL_NEW (fn s =&gt; fn x =&gt; Clasimp.fast_force_tac
                      (Guess_Instantiate.add_guess_inst_solver ctxt addsimps @{thms' Premise_def}) s x)*)</span></span><span> </span><span class="main"><span>)</span></span><span>
               </span><span class="main"><span>)</span></span><span>
              </span><span>|&gt;</span><span> </span><span>Seq.take</span><span> </span><span class="inner_numeral"><span>1</span></span><span> </span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>Safe_Solver</span></span><span> </span><span class="entity"><span>th'</span></span><span>
       </span><span>|&gt;</span><span> </span><span>Seq.take</span><span> </span><span class="inner_numeral"><span>1</span></span><span>
       </span><span>|&gt;</span><span> </span><span>Seq.pull</span><span>
      </span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span class="main"><span>)</span></span><span>
  </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Safe_Simps.equip</span></span><span> </span><span class="entity"><span>ctxt0</span></span><span class="main"><span>)</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>val</span></span></span><span> </span><span class="entity"><span>safe_obligation_solver'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="entity"><span>context_tactic_to_state_transition</span></span><span> </span><span>o</span><span> </span><span class="entity"><span>safe_obligation_solver</span></span><span>

</span><span class="keyword1"><span class="keyword"><span>fun</span></span></span><span> </span><span class="entity"><span>safe_obligation_solver1</span></span><span> </span><span class="entity"><span>can_inst</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>sequent</span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity"><span>safe_obligation_solver'</span></span><span> </span><span class="entity"><span>can_inst</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span class="keyword"><span>fn</span></span></span><span> </span><span class="main"><span>_</span></span><span> </span><span class="main"><span>=&gt;</span></span><span>
    </span><span>error</span><span> </span><span class="main"><span>(</span></span><span>Pretty.string_of</span><span> </span><span class="main"><span>(</span></span><span>Pretty.chunks</span><span> </span><span class="main"><span>[</span></span><span>
        </span><span>Pretty.str</span><span> </span><span class="inner_quoted"><span>"Fail to solve the proof obligation automatically:"</span></span><span class="main"><span>,</span></span><span>
        </span><span>Syntax.pretty_term</span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="main"><span>(</span></span><span class="entity"><span>Phi_Help.leading_antecedent'</span></span><span> </span><span class="entity"><span>sequent</span></span><span class="main"><span>)</span></span><span>
  </span><span class="main"><span>]</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span> </span><span class="entity"><span>ctxt</span></span><span> </span><span class="entity"><span>sequent</span></span><span>

</span><span class="comment1"><span>(*case Thm.major_prem_of sequent
    of <span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>‹Trueprop› $ (<span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span>‹Premise› $ _ $ Goal) =&gt; (
        (*Phi_Reasoner.info_pretty ctxt 2 (fn _ =&gt; Pretty.chunks [
            Pretty.str "Solving the following goal using ‹clarsimp› method...",
            Syntax.pretty_term ctxt Goal,
            Pretty.block (Pretty.here ⌂)
        ]); *)
        guard_condition_solver' (fn _ =&gt;
          error (Pretty.string_of (Pretty.chunks [
              Pretty.str "Fail to solve the proof obligation automatically:",
              Syntax.pretty_term ctxt (Phi_Help.leading_antecedent' sequent)
        ]))) (ctxt addsimps @{thms Premise_def}) sequent
     )
     | _ =&gt; raise THM ("auto_obligation_solver1: The leading antecedent of the given sequent \
              \is not a proof obligation.", 1, [sequent])*)</span></span><span>



</span><span class="comment1"><span>(*fun declare_local_assume_reasoners sequent i *)</span></span><span>




</span><span class="keyword2"><span class="keyword"><span>end</span></span></span><span>
</span></pre>
</body>

</html>