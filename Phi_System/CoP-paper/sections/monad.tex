\section{Monadic Formalization of the Semantics}\label{sec:prog-sem}

In the paper, we adopt nondeterministic state monad to formalize the semantics of the parameterized programming language.
It covers a large part of semantics in sequential and terminable imperative languages, which are our focus.

Although the paper does not consider exceptions for the sake of focusing on the essence of the work in the limited space, our implementation in Isabelle/HOL does extend the work to exceptions and we refer interesting readers to the source.


Above any specific semantic formalizations, we abstract two essential notions of imperative programs, \emph{procedure} and \emph{control flow combinator}.

%CoP is parameterized by a monadic formalization of the semantics of a specific programming language, which supports mutable resource and exception.

Procedure is the minimal building block in the programming of CoP.
It represents a segment of a program, which is defined inductively,
\begin{itemize}
\item Any instruction instantiated by any arguments is a procedure.
\item Any lambda abstraction of a procedure is a procedure.
\item Sequential composition of two procedures is a procedure.
\item Control flow combinator combines several procedures into a procedure.
\end{itemize}
Control flow combinator detailed later may include branches, loops but not the sequential composition.

Functions, routines, or sub-routines in the parameterized language are represented as procedures,m
and procedures can be extracted to them with additional signature information like names and types of arguments.
However, an arbitrary procedure does not necessarily correspond to a routine or any of its relatives.
It abstracts a fragment of a routine.% or more generally a program.
%The notion of procedure abstracts fragments of programs.
%The motivation to abstract program segments to serve as the basic building block of the programming.

We model procedure by nondeterministic state monad of type $\mathrm{State} \rightarrow \mathbf{M}~\mathrm{set}$.
\begin{gather*}
\mathbf{M} \Coloneqq \mathrm{Success}\;v\;s \mbar \mathrm{NonTerm} \mbar \mathrm{Invalid},\qquad
  \text{where $v \in \mathrm{Value},\ s \in \text{State}$}
\end{gather*}
State represents states of resources.
The four constructors of $\mathbf{M}$ represents respectively a normal termination with return value $v$ and of state $s$, an abnormal exit with exception $e$ and of state $s$, non-termination of the computation, and invalid computation which represents the computation violates the semantics of the language or involves undefined behaviors.
A procedure is valid iff it never returns Invalid.

Bodies in control flows are also procedures.
A control flow structure is modelled by the combination of a control flow combinator and several procedures modelling the bodies.
These procedures are named {\it sub-procedures} relatively to the outer procedure containing the control flow.
A control flow combinator is a higher-order monads that accept other procedure monads (namely monads modelling a procedure) as their parameters, e.g.,
the branch statement \texttt{if (c) \{Bt\} else \{Bf\}} is modelled by monad $(\mathrm{IF}\,c\,B_T\,B_F)$ where (IF) is a higher-order monadic combinator, $c$ is a normal value, and $B_T, B_F$ are procedure monads.

