\section{Monadic Semantics of Programs}\label{sec:prog-sem}

CoP is parameterized by a monadic formalization of the semantics of a specific programming language, which supports mutable resource and exception.

Procedure is the minimal building block in the programming of CoP.
It represents a segment of a program, which is defined inductively,
\begin{itemize}
\item Any instruction instantiated by any arguments is a procedure.
\item Any lambda abstraction of a procedure is a procedure.
\item Sequential composition of two procedures is a procedure.
\item Control flow combinator combines several procedures into a procedure.
\end{itemize}
Control flow combinator detailed later may include branches, loops but not the sequential composition.

Any function, routine, or sub-routine in the parameterized language is a procedure
and procedures are able to be extracted into functions or routines in the parameterized language with necessary signature information like the name.
However, an arbitrary procedure does not necessarily correspond to any of them (functions or routines).
The motivation of the notion is to abstract program segments to serve as the basic building block of the programming.

A procedure is modelled by a state-error monad of type $\mathrm{State} \rightarrow \mathbf{M}$.
\begin{gather*}
\mathbf{M} \Coloneqq \mathrm{Success}\;v\;s \mbar \mathrm{Exception}\;e\;s \mbar \mathrm{NonTerm} \mbar \mathrm{Invalid}\\
v \in \mathrm{Value} \qquad s \in \text{State} \qquad e \in \mathrm{Exception}
\end{gather*}
State represents states of resources.
The four constructors of $\mathbf{M}$ represents respectively a normal termination with return value $v$ and of state $s$, an abnormal exit with exception $e$ and of state $s$, non-termination of the computation, and invalid computation which represents the computation violates the semantics of the language or involves undefined behaviors.
A procedure is valid iff it does not returns Invalid in any case of input.

Bodies in control flows are also procedures.
A control flow structure is modelled by the combination of a control flow combinator and several procedures modelling the bodies.
These procedures are named {\it nested procedures} relatively to the outer procedure containing the control flow.
A control flow combinator is a higher-order monads that accept other procedure monads (namely monads modelling a procedure) as their parameters, e.g.,
the branch statement \texttt{if (c) \{Bt\} else \{Bf\}} is modelled by monad $(\mathrm{if}\,c\,B_T\,B_F)$ where (if) is a higher-order monadic combinator, $c$ is a normal value, and $B_T, B_F$ are procedure monads.

