\section{Calculus of Programming}

Calculus of Programming is an extension of φ-BI for programming and also verification.
It in essence puts the strongest post-condition transformer before the $(\vdash)$ of the sequents, like $sp[C](P) \vdash Q$ emblematically, together with the supports for lambda variables of the monadic program. % and assertions for exception.

To support onward construction of monadic programs is the main motivation of introducing a new form of sequent and a deduction system.
The conventional bind rule already supports forward reasoning used in the verification.
\begin{prooftree}
  \AxiomC{$\{P\}f\{Q\}$}
  \AxiomC{$\forall v.\{Q\,v\}g\,v\{R\}$}
  \RightLabel{(Bind)}
  \BinaryInfC{$\{P\} f \bind g \{R\}$}
\end{prooftree}
However, the rule is not feasible for onward programming, because the structure of monad does not allow an easy forward construction from $f_1 \bind (\lambda v_1.\,f_2 \bind (\lambda v_2.\,f_3 \bind \cdots f_n \cdots))$ to $f_1 \bind (\lambda v_1.\,f_2 \bind (\lambda v_2.\,f_3 \bind \cdots f_n \bind (\lambda v_n.\, f_{n+1}) \cdots))$ without opening the lambda abstractions.
It motivates us to buffer lambda variables like $P \mbar (f_1,v_1); (f_2,v_2);\cdots;(f_n,v_n) \vdash Q$ to open the lambda abstractions during the programming and at last assemble it back into a monad.

\subsection{Syntax \& Semantics of CoP Sequent}\label{CoP-sem}

A CoP sequent representing an on-going constructions of a program is in form,
\[ P \mbar S ⊢ Q \qquad\qquad \text{where $S \Coloneqq ⋅ ~|~ S \mathrel{;} (f,v)$} \]
Hypothesis (pre-condition) $P$ and conclusion (post-condition) $Q$ are φ-BI assertions,
$f$ is a procedure, variable $v$ is the return value of the procedure.
Return values of former procedures are available to be used in later procedures in $S$.

%$\mathbf{choice}\,P'$ is a \emph{pseudo} procedure specified by $\{\exists P\}\,\mathbf{choice}\,P\,\{P\}\{\lambda\_.\bot\}$ and defined by $(\mathbf{choice}\,P\triangleq \mathrm{return}\;\xepsilon P)$ where $\xepsilon$ is Hilbert's choice operator.
%It is not a semantic operation but a technical artifact used to fix existentially quantified variables locally.
%The fixed quantified variable $x$ is not a semantic return value.

$S$ is a sequence of procedures representing the current construct during the programming.
Semantic interpretation $\seminterp{S}_r$ translates a sequence returning $r$ to a monadic program,
\[ \seminterp{⋅}_r ≜ \mathrm{return}\;r \qquad \seminterp{(f, v) \mathbin{;} S}_r ≜ f \bind (\lambda v.\; \seminterp{S}_r)\]
%It is obvious any monadic program can be represented in an equivalent sequence of instructions
%(or any atomic sub-procedures as a single construction step).

The semantics of sequent $P \mbar S ⊢ Q$ specifies, from an input state $s$ satisfying $P$, any normal (successful) execution of $\seminterp{S}_r$ results in some output state $s'$ with return value $y$ satisfying $Q'\,y$,
\begin{gather*}
  (P \mbar S ⊢ Q) ≡ ∀ s\,s'\,y.\; (s ⊨ P) \land \mathrm{Success}\;y\;s' ∈ \seminterp{S}_r(s) \longrightarrow (s' ⊨ Q'\,y)\\
  \small
  r = \mathrm{Free}(Q) \cap \mathrm{Vals}(S) \qquad Q' = \lambda r.\; Q \qquad
  \mathrm{Vals}(S) \triangleq \{ v : (f,v) \in S\ \ \text{for some $f$}\} \normalsize
\end{gather*}
where $r$ is a tuple of all values occurring in the post-condition $Q$ and $Q'$ is the lambda abstraction of $Q$ over $r$ meaning $Q = Q'\,r$ and $r$ are not free in $Q'$.
\begin{remark}
\emph{We assign semantics of values (such as $r$) occurring in post-condition (such as $Q$) as the values to be returned from the procedure.}
It is in fact the only reasonable interpretation for the free occurrence of values in a post-condition.
\end{remark}
%Note $P \mbar S ⊢ Q$ focuses on only the normal execution.

%\begin{remark}
%  We write $P ⊢ Q$ for $P \mbar ⋅ ⊢ Q$ directly.
%\end{remark}

