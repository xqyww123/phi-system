\section{Specifications of Program}

Monadic programs formalized in the previous section are specified on the dynamic implementation of φ-SL on φ-BI, where following the well-known approach of Dynamic Logic, we extend φ-BI with $[C]$-modality and define Hoare triplet $\{P\}C\{Q\}$ over it.
The section first introduces the background of φ-BI and φ-SL (\cref{sec:background}), and explicates the $[C]$-modality in \cref{sec:wp}.

\subsection{Background of φ-BI and φ-SL}\label{sec:background}

....

%In φ-BI, all pure assertions are in form $@_w P$ and all assertions in form $@_w P$ are (convertible to) pure assertions. Therefore, though different with the original definition, for the convenience of the paper, we redefine pure assertions as any assertions in form $@_w P$.

\subsection{$[C]$-Modality \& Hoare Triple \& Other Terms}\label{sec:wp}
Semantically, $[C]$-modality $\wpm{C}{Q}$ represents,
starting from the present state $s$,
the execution of the monadic program $C$
results in either some successful state $\mathrm{Success}\;v\;s'$ with $s' ⊨ Q\,v$,
%or some exceptional state $\mathrm{Exception}\;e\;s'$ with $s' ⊨ E\,e$,
or optionally NonTerm depending on the configuration of total correctness or partial correctness.
It is actually a weakest pre-condition transformer, but we do not use this name because our method has bare connection with theirs.

It is well-known Hoare triplet can be defined above it,
saying that if the present state $s$ satisfies $P$, then the execution of $C$ satisfies the above semantics.
\[\{P\}C\{Q\} ~\triangleq~ P \longrightarrow \wpm{C}{Q} \tag{HQ}\label{def:HQ}\]

%A procedure $C$ is specified by a triplet $\{P\}C\{Q\}\{E\}$ where $P, Q$ are the conventional pre- and post-condition respectively and $E$ is the specification for abnormal exits by exceptions.
Recall control flow combinators in \cref{sec:prog-sem} which are higher-order monads.
The specifications of the procedural parameters (namely the parameters that are a procedure) are given in antecedents of implications over the triplet, e.g.,
\[ \{P\}B_T\{Q_T\} \Longrightarrow \{P\}B_F\{Q_F\} \Longrightarrow
      \{P\}~\mathrm{IF}\;c\;B_T\;B_F~\{(c \longrightarrow P_T) \land (¬c \longrightarrow P_F)\} \]
Note, the specifications of any-order procedures are indeed Heredity Harrop Formulas (HHFs).
HHF is the orthodox form of formulas in logic programming, which is also the way of how sub-procedures are constructed as shall be elaborated in \cref{sec:process}.

\begin{remark}
$A \Longrightarrow C$ represents an implication where the antecedent $A$ is a standalone assertion irrelevant with the present resource specified by the consequence $C$.
$(A \Longrightarrow C) \triangleq (∀w.\,@_w A) \longrightarrow C$.
It coincides with the implication in the meta-logic (that implements the BI).
If semantic interpretation $\seminterp{\cdot}$ represents the validity of a φ-BI sequent by a meta-logic proposition,
  there is $\seminterp{\Gamma \vdash (A \Longrightarrow C)} = (\seminterp{\vdash A} \longrightarrow \seminterp{\Gamma \vdash C})$.
\end{remark}

\begin{remark}\label{ACF}
  For nested implications $A_1 \longrightarrow \cdots \longrightarrow A_n \longrightarrow C$, we also write them in and consider them transparently undistinguishable with the equivalent aggregated conjunctions as $A_1 \land \cdots \land A_n \longrightarrow C$ for the convenience of discussion.

A universal form of procedure specifications is then $A \Longrightarrow \{P\}C\{Q\}$ where antecedents $A$ specify procedural parameters as in the \texttt{IF} above. $A$ can be trivially $\top$ for empty antecedents.
We name the proven specifications $\vdash A \Longrightarrow \{P\}C\{Q\}$ as \emph{Specification Theorems} of procedure $C$.
\end{remark}

\begin{remark}\label{HHF}
  Another term frequently used below is HHF generated from a set $A$. Denoted by $\mathrm{HHF}(A)$, it is defined inductively as the minimum set containing $A$ and closed under $(\Longrightarrow)$, i.e., if $\phi, \psi \in \mathrm{HHF}(A)$ then $(\phi \Longrightarrow \psi) \in \mathrm{HHF}(A)$.

\end{remark}

\subsection{Canonical Form of Assertions \& Its Automation}

As abstractions are reflected syntactically instead of semantically in φ-BI and φ-SL, syntactic form of assertions is significant.
In \cite{phiTy}, Xu used {\it Single-Term Form} as the base of analyses, $\{ x \tycolon T \mbar_{\vec a} P \}$, which reflects the abstraction straightforwardly and covers all expressiveness.
We relax it a bit by allowing $\ast$-sequence of φ-types to support localized abstraction of separations.
\begin{definition}
Multi-Term Form (MTF) is characterized by, for any $n$
  \[ \{ x_1\tycolon T_1 \ast \cdots \ast x_n \tycolon T_n \mbar_{\vec a} P \} \qquad\text{which is also denoted by $\{\Asterisk_i^n x_i\tycolon T_i \mbar_{\vec a} P\}$}\]
More often in the paper, we represent the above MTF equivalently as $\{x \tycolon T \mathrel{|} P\}$ for $x=(x_1,\cdots,x_n)$ and $T=(T_1\hat\ast \cdots \hat\ast T_n)$ where by definition $(x,y) \tycolon (T\hat\ast U) = (x \tycolon T) \ast (y \tycolon U)$.
\end{definition}
\noindent
It relates the concrete object to a set of abstract objects $\bigcup_{\vec a : P}\{(x_1,\cdots,x_n)\}$ w.r.t abstraction relation $T_1 \hat\ast \cdots \hat\ast T_n$, if variables $\vec a$ are not free in $T_1,\cdots,T_n$.
%\begin{remark} $\exists$-Free MTF is the MTF that has no existential quantification.
%\end{remark}

We regard MTF transparently over rewrite. So the separate conjunction $X \ast Y$ of two MTF $X,Y$ is also in MTF, by rewriting the inner conjunctions and existential quantifications in $X,Y$ to the outmost.

Assertions in the automation in the paper are closed in MTF.
A direct benefit is, any implication in the reasoning (esp. from Consequence rule) is between MTFs, which has a clear logical meaning, \emph{transformation of abstractions}.

%Specifically, when applying a quadruple of pre-condition $X'$ on post-condition $X$, with $X', X$ in MTF, we have to solve an implication $X \longrightarrow\;?R \ast X'$ by choosing certain $?R$ so that by frame rule we can apply the quadruple.
%Certainly there is a universal solution, $?R \equiv X' \wand X$, but it breaks MTF and does not reflect abstraction in a straightforward way (indeed what it reflects is a pending transformation of abstraction to be solved).
%Therefore, we restrict that the $?R$ must also in MTF.
%As an algorithm to solve transformations of abstraction, we require this transformation $X \wand X'$ is direct that $X$ unifies $X'$.
%%The reasoning of $\text{STEP}_{\rightarrow}$ preserves MTF.

We formulate the problem of mechanizing transformations of abstraction, which extracts \emph{abstract} verification conditions to establish the transformation.
\begin{definition}[The problem of Verification Condition Generation (VCG) for Transformation of Abstraction (ToA)]\label{prob1}\label{VCG-ToA}
  Given an abstraction transformation goal in MTF, $\{ \Asterisk_i^n x_i\tycolon T_i \mbar_{\vec a} P \} \longrightarrow
  \;?R \ast \{ \Asterisk_j^m y_j\tycolon U_j \mbar_{\vec b} Q \}$,
  the problem of generating verification conditions (VCs) for the transformation is to find a {\bf pure} and {\bf abstract} proposition $V_C$ by choosing certain frame variable $?R$ in MTF, such that $V_C$ entails the goal, i.e., $V_C \Longrightarrow (\{ \Asterisk_i^n x_i\tycolon T_i \mbar_{\vec a} P \} \longrightarrow\; ?R \ast \{ \Asterisk_j^m y_j\tycolon U_j \mbar_{\vec b} Q \})$.
  The problem has a strict version, where $?R$ is fixed to emp, causing the transformation total.
%  A proposition is {\bf abstract} iff it specifies only abstract objects.
%
%  %all variables constrained in the proposition are in the abstraction domain given by the abstraction relations $(T_i, U_j)$, i.e., the proposition specifies only abstract objects.
%
%  depends on only (free variables in) $x_i,y_j,P,Q$ and parameters of $T_i,U_j$ for $1 \leq i \leq n$, $1 \leq j \leq m$, that is, the proposition is in the abstraction domain given by the abstraction relations ($T_i, U_j$). This $V_C$ is the verification condition.
\end{definition}
The notion of abstract proposition is relative.
A proposition is {\bf abstract} iff it specifies only objects in the abstract domain given by the abstraction relations and excluding any representations in the concrete side.
The definition is not strict and the notion is used solely for a loose distinction between the abstract VCs and the conventional VCs consisting of concrete representations.
%For example, if the abstraction relation is the identity relation relating objects to themselves, then any pure proposition is abstract. By contrast, if the abstraction relation relates some concrete representations to natural numbers, a pure proposition should specify only natural numbers instead of any representations in the concrete side.

The frame variable $?R$ is prepared for frame rule --- the transformation goal only means to transform a part of the abstraction.
The question mark emphasizes $?R$ is a variable that can be instantiated arbitrarily.
Certainly $?R \equiv X' \wand X$ is a universal solution, but it breaks MTF and does not reflect abstraction in a straightforward way. Indeed what it reflects is a pending transformation of abstraction to be solved instead of any direct abstraction, so the problem is not really solved.
Therefore, we exclude wand and restrict $?R$ must be in MTF.

We suspend here leaving solution of the problem~\ref{prob1} to the section ??? and turn to the calculus for programming and also verifying programs.
%
%makes the transformation partial --- only a part of the abstraction is transformed to the destination leaving the remain unchanged.



