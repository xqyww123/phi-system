Abstractions of programs boosts the efficiency of verification because they express the meaning and intention of the code more clearly and precisely. For example, the rule \texttt{split}: $\{\cdots\}\texttt{pointer\_add}\{\cdots\}$ than the rule \texttt{pointer\_add}: $\{\cdots\}\texttt{pointer\_add}\{\cdots\}$ expresses clearer intention and hint the reasoning a lot, albeit their executable code are the same. Strictly speaking, the rule \texttt{split} is an annotated version of the \texttt{pointer\_add} admittedly. However, we argue annotations do not necessarily mean the inefficiency, especially when they make the code more readable, clearer and more precise. The productivity of software engineering does not only depend on how fast or how little a programmer can write. Instead, a program language that expresses the intention of the programmer in a logic and clear way is more desirable, even though some annotations are required but if they are not verbose it deserves. Abbreviation is such a desirable method because it is succinct. The more informative rule the user choose is merely an abbreviation of the direct code from the view of burden.
